<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RVsion - Répétition Espacée & Tests AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Styles personnalisés pour une meilleure lisibilité et esthétique */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Arrière-plan gris clair */
        }
        .container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        .btn {
            @apply px-4 py-2 rounded-lg font-medium transition-all duration-200 flex items-center justify-center gap-2; /* Ajout gap pour les icônes */
        }
        .btn-primary {
            @apply bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800;
        }
        .btn-secondary {
            @apply bg-gray-200 text-gray-800 hover:bg-gray-300 active:bg-gray-400;
        }
        .btn-success {
            @apply bg-green-500 text-white hover:bg-green-600 active:bg-green-700;
        }
        .btn-warning {
            @apply bg-yellow-500 text-white hover:bg-yellow-600 active:bg-yellow-700;
        }
        .btn-danger {
            @apply bg-red-500 text-white hover:bg-red-600 active:bg-red-700;
        }
        .btn-info {
            @apply bg-cyan-500 text-white hover:bg-cyan-600 active:bg-cyan-700;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 700px;
            transform: translateY(-20px);
            opacity: 0;
            animation: fadeInScale 0.3s forwards;
            max-height: 90vh;
            overflow-y: auto;
        }
        @keyframes fadeInScale {
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .score-button {
            @apply w-12 h-12 flex items-center justify-center text-lg font-bold rounded-full border-2 border-transparent transition-all duration-200;
        }
        .score-button:hover {
            @apply border-blue-500;
        }
        .score-button.selected {
            @apply bg-blue-500 text-white border-blue-600;
        }
        .document-content-display {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 12px; /* Slightly more rounded */
            padding: 1.5rem; /* Increased padding */
            margin-bottom: 1.5rem;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
            /* NEW STYLES for readability */
            font-family: 'Lato', sans-serif; /* Modern, clean font */
            font-size: 1.05rem; /* Slightly larger text */
            line-height: 1.6; /* Improved line spacing */
            color: #374151; /* Darker grey for better contrast */
        }
        .loading-spinner {
            border: 4px rgba(0, 0, 0, 0.1);
            border-left-color: #2563eb;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Styles pour les messages d'alerte/confirmation */
        .alert-message {
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 500;
        }
        .alert-success {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #34d399;
        }
        .alert-error {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
        .alert-info {
            background-color: #dbeafe;
            color: #1e40af;
            border: 1px solid #60a5fa;
        }
        .alert-warning {
            background-color: #fffbeb;
            color: #b45309;
            border: 1px solid #fcd34d;
        }

        /* Styles spécifiques au quiz interactif */
        .quiz-option {
            @apply flex items-center p-3 rounded-lg border border-gray-300 cursor-pointer transition-colors duration-200;
        }
        .quiz-option:hover {
            @apply bg-gray-100;
        }
        .quiz-option.selected {
            @apply bg-blue-100 border-blue-500;
        }
        .quiz-option input[type="radio"] {
            @apply mr-3;
        }

        /* Chat Message Animations */
        .chat-message-user, .chat-message-ai {
            opacity: 0;
            transform: translateY(20px);
            animation: slideInFadeIn 0.3s ease-out forwards;
        }

        .chat-message-user {
            background-color: #dbeafe; /* Blue-100 for user messages */
            align-self: flex-end; /* Align to right */
        }

        .chat-message-ai {
            background-color: #e5e7eb; /* Gray-200 for AI messages */
            align-self: flex-start; /* Align to left */
        }

        @keyframes slideInFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Flashcard specific styles */
        .flashcard-wrapper {
            perspective: 1000px; /* Needed for 3D flip */
            width: 100%;
            height: 250px; /* Fixed height for the card */
            margin: 0 auto;
            position: relative;
        }

        .flashcard-card {
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Subtle shadow */
        }

        .flashcard-card.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden; /* Hide back of the card during flip */
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            border-radius: 1rem;
            text-align: center;
            font-size: 1.25rem;
            font-weight: 600;
            color: #374151;
        }

        .flashcard-front {
            background: linear-gradient(135deg, #fef2f2, #fee2e2); /* Light red gradient */
            border: 2px solid #fca5a5;
        }

        .flashcard-back {
            background: linear-gradient(135deg, #d1fae5, #a7f3d0); /* Light green gradient */
            border: 2px solid #6ee7b7;
            transform: rotateY(180deg);
            color: #065f46; /* Darker green for text */
            font-style: normal;
        }

        .flashcard-text-content {
            padding: 1rem;
            border-radius: 0.5rem;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }
        
        /* Adaptations mobiles - À ajouter dans votre section <style> */
        @media (max-width: 768px) {
            .container {
                margin: 0.5rem;
                padding: 1rem;
                border-radius: 8px;
            }
            
            /* Réduction des marges/padding sur mobile */
            .mobile-reduced-padding {
                padding: 0.5rem !important;
            }
            
            .mobile-text-sm {
                font-size: 0.875rem !important;
            }
            
            /* Stack les éléments flex sur mobile */
            .mobile-stack {
                flex-direction: column !important;
            }
            
            /* Pleine largeur sur mobile */
            .mobile-full-width {
                width: 100% !important;
            }
            
            /* Espacement réduit sur mobile */
            .mobile-gap-2 {
                gap: 0.5rem !important;
            }
            
            /* Boutons adaptés mobile */
            .mobile-btn-small {
                padding: 0.5rem 0.75rem !important;
                font-size: 0.875rem !important;
            }
            
            /* Modales adaptées mobile */
            .modal-content {
                margin: 1rem !important;
                max-height: 95vh !important;
                overflow-y: auto !important;
            }
        }

        @media (max-width: 480px) {
            /* Très petits écrans */
            .container {
                margin: 0.25rem;
                padding: 0.75rem;
            }
            
            .mobile-xs-text {
                font-size: 0.75rem !important;
            }
            
            .mobile-xs-btn {
                padding: 0.375rem 0.5rem !important;
                font-size: 0.75rem !important;
            }
        }

        /* Style responsive pour les tableaux */
        @media (max-width: 768px) {
            .table-responsive {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .table-responsive table {
                min-width: 600px;
            }
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4">
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-blue-700 mb-6">RVsion</h1>

        <div class="mb-8 p-6 bg-gray-50 rounded-lg shadow-sm">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Ajouter un nouveau document</h2>
            <div class="flex flex-col gap-4">
                <input type="text" id="documentNameInput" placeholder="Nom du document ou du cours"
                        class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                
                <select id="documentCategorySelect" class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="">Sélectionner une catégorie</option>
                </select>
                <select id="documentSubcategorySelect" class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                    <option value="">Sélectionner une sous-catégorie</option>
                </select>

                <textarea id="documentContentInput" placeholder="Contenu du document (notes, concepts clés...)"
                                rows="6" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y"></textarea>
                
                <div class="mt-2 p-3 bg-blue-50 rounded-lg border border-blue-200">
                    <label for="aiDocumentActionSelect" class="block text-sm font-medium text-blue-800 mb-2">Action AI sur le contenu (avant ajout) :</label>
                    <select id="aiDocumentActionSelect" class="p-2 border border-blue-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="none">Ne rien faire (laisser normal)</option>
                        <option value="develop">Développer/Créer le cours (à partir d'une idée)</option>
                        <option value="optimize">Optimiser/Simplifier le cours (contenu existant)</option>
                    </select>
                </div>
                <div id="aiDocumentActionLoading" class="flex justify-center items-center py-2 hidden">
                    <div class="loading-spinner"></div>
                    <p class="ml-2 text-blue-600">L'IA travaille sur votre contenu...</p>
                </div>
                <button id="addDocumentBtn" class="btn btn-primary">➕ Ajouter le document</button>
            </div>
            <div class="mt-4">
                <button id="manageCategoriesBtn" class="btn btn-secondary w-full">⚙️ Gérer les Catégories</button>
            </div>
        </div>
        <div class="flex flex-col md:flex-row md:justify-between md:items-center mb-6 gap-4">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">RVsion - Répétition Espacée & Tests AI</h1>
            <div class="flex flex-col sm:flex-row gap-2 sm:items-center">
                <input type="password" id="apiKeyInput" placeholder="Clé API Gemini" 
                    class="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 w-full sm:w-auto">
                <button id="saveApiKeyBtn" class="btn btn-primary mobile-btn-small">💾 Sauver</button>
            </div>
        </div>

        <div class="mb-8 p-6 bg-blue-50 rounded-lg shadow-sm">
            <h2 class="text-2xl font-semibold text-blue-700 mb-4">Documents à réviser aujourd'hui</h2>
            <div id="documentsDueToday" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <p id="noDocumentsDue" class="text-gray-600 italic">Aucun document à réviser aujourd'hui. Bravo !</p>
            </div>
        </div>

        <div class="mb-8 p-6 bg-purple-50 rounded-lg shadow-sm">
            <h2 class="text-2xl font-semibold text-purple-700 mb-4">Mes Tests AI (En attente/En cours)</h2>
            <div id="aiTestsSavedList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <p id="noAITestsSaved" class="text-gray-600 italic">Aucun test AI en attente. Générez-en un !</p>
            </div>
        </div>

        <div class="p-6 bg-gray-50 rounded-lg shadow-sm">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Tous mes documents</h2>
            <div class="mb-4 flex flex-col sm:flex-row gap-4 items-center">
                <input type="text" id="searchDocumentInput" placeholder="Rechercher un document..."
                        class="p-2 border border-gray-300 rounded-lg flex-grow focus:outline-none focus:ring-2 focus:ring-blue-500">
                <select id="filterStatusSelect" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="all">Tous les statuts</option>
                    <option value="due">À réviser aujourd'hui</option>
                    <option value="not-due">Non dus</option>
                </select>
                <select id="filterCategorySelect" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="all">Toutes catégories</option>
                </select>
                <select id="filterSubcategorySelect" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                    <option value="all">Toutes sous-catégories</option>
                </select>
            </div>
            <div id="allDocumentsList" class="grid grid-cols-1 gap-4">
                <p id="noDocumentsYet" class="text-gray-600 italic">Vous n'avez pas encore ajouté de documents.</p>
            </div>
        </div>

        <div class="mt-8 p-6 bg-gray-50 rounded-lg shadow-sm flex flex-col sm:flex-row justify-between items-center gap-4">
            <h2 class="text-2xl font-semibold text-gray-700">Outils de gestion des données</h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <button id="exportDataBtn" class="btn btn-secondary">📥 Exporter les données</button>
                <input type="file" id="importFileInput" accept=".json" class="hidden">
                <button id="importDataBtn" class="btn btn-secondary">📤 Importer les données</button>
            </div>
        </div>
    </div>

    <!-- Modale de Révision -->
    <div id="reviewModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Révision de : <span id="modalDocumentName" class="font-bold text-blue-600"></span></h3>
            <div id="modalDocumentContent" class="document-content-display"></div>
            
            <div class="mt-6 p-4 bg-gray-100 rounded-lg border border-gray-200">
                <h4 class="text-lg font-semibold text-gray-700 mb-3">Posez une question à l'IA sur ce cours</h4>
                <div id="aiChatDisplay" class="h-40 overflow-y-auto bg-white p-3 rounded-lg border border-gray-300 mb-3 flex flex-col space-y-2 text-sm">
                    <p class="text-gray-500 italic text-center">Posez votre première question !</p>
                </div>
                <div id="aiChatLoading" class="flex justify-center items-center py-2 hidden">
                    <div class="loading-spinner"></div>
                    <p class="ml-2 text-blue-600">L'IA réfléchit...</p>
                </div>
                <div class="flex gap-2 mt-3">
                    <input type="text" id="aiChatInput" placeholder="Votre question ici..."
                               class="p-2 border border-gray-300 rounded-lg flex-grow focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="sendAIChatBtn" class="btn btn-primary">Envoyer</button>
                </div>
            </div>
            <p class="text-gray-600 mb-6 mt-6">Évaluez la facilité de la révision (1 = Oublié, 5 = Très facile)</p>
            <div class="flex justify-around gap-2 mb-6">
                <button class="score-button bg-red-100 text-red-700" data-score="1">1</button>
                <button class="score-button bg-orange-100 text-orange-700" data-score="2">2</button>
                <button class="score-button bg-yellow-100 text-yellow-700" data-score="3">3</button>
                <button class="score-button bg-lime-100 text-lime-700" data-score="4">4</button>
                <button class="score-button bg-green-100 text-green-700" data-score="5">5</button>
            </div>
            <div class="flex justify-end gap-4">
                <button id="cancelReviewBtn" class="btn btn-secondary">Annuler</button>
                <button id="submitReviewBtn" class="btn btn-primary" disabled>Soumettre l'évaluation</button>
            </div>
        </div>
    </div>

    <!-- Modale de configuration du test AI -->
    <div id="testConfigModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Préparer le Test AI pour : <span id="testConfigDocumentName" class="font-bold text-blue-600"></span></h3>
            <div id="testConfigInputs" class="flex flex-col gap-4 mb-6">
                <div>
                    <label for="studyLevelInput" class="block text-sm font-medium text-gray-700 mb-1">Niveau d'étude :</label>
                    <select id="studyLevelInput" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="">Sélectionner un niveau</option>
                        <option value="Primaire">Primaire</option>
                        <option value="Collège">Collège</option>
                        <option value="Lycée">Lycée</option>
                        <option value="Université">Université</option>
                        <option value="Professionnel">Professionnel</option>
                        <option value="Autre">Autre</option>
                    </select>
                </div>
                <div>
                    <label for="difficultyInput" class="block text-sm font-medium text-gray-700 mb-1">Niveau de difficulté du test :</label>
                    <select id="difficultyInput" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="Très facile">Très facile</option>
                        <option value="Facile">Facile</option>
                        <option value="Moyen">Moyen</option>
                        <option value="Difficile">Difficile</option>
                        <option value="Très difficile">Très difficile</option>
                    </select>
                </div>
                <div>
                    <label for="questionTypeInput" class="block text-sm font-medium text-gray-700 mb-1">Type de questions :</label>
                    <select id="questionTypeInput" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="qcm">QCM (Questions à Choix Multiples)</option>
                        <option value="written">Questions Écrites (Réponse Libre)</option>
                        <option value="mixed">Mixte (QCM et Écrites)</option>
                    </select>
                </div>
                <div>
                    <label for="numQuestionsInput" class="block text-sm font-medium text-gray-700 mb-1">Nombre de questions (1-20) :</label>
                    <input type="number" id="numQuestionsInput" value="5" min="1" max="20"
                               class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="additionalContextInput" class="block text-sm font-medium text-gray-700 mb-1">Contexte ou instructions supplémentaires pour l'IA :</label>
                    <textarea id="additionalContextInput" placeholder="Ex: Pose des questions à choix multiples, Concentre-toi sur les dates..."
                                rows="3" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y"></textarea>
                </div>
            </div>
            <div class="flex justify-end gap-4">
                <button id="cancelTestConfigBtn" class="btn btn-secondary">Annuler</button>
                <button id="prepareInteractiveTestBtn" class="btn btn-primary">✨ Préparer le Test Interactif</button> </div>
        </div>
    </div>

    <!-- Modale pour répondre au test AI (Interactive Quiz) -->
    <div id="doTestModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Test Interactif AI pour : <span id="doTestDocumentName" class="font-bold text-blue-600"></span></h3>
            
            <div id="quizGenerationLoading" class="flex justify-center items-center py-8 hidden">
                <div class="loading-spinner"></div>
                <p class="ml-4 text-gray-600">Génération du test interactif par l'IA...</p>
            </div>

            <div id="quizDisplayArea" class="hidden">
                <div class="flex justify-between items-center mb-4">
                    <span class="text-lg font-semibold text-gray-700">Question <span id="currentQuestionNumber">1</span>/<span id="totalQuestions">X</span></span>
                    <span class="text-lg font-semibold text-gray-700">Temps écoulé : <span id="testTimer" class="font-bold text-blue-600">00:00:00</span></span>
                </div>

                <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <p id="quizQuestionText" class="text-lg font-medium text-gray-800 mb-4"></p>
                    <div id="quizQuestionOptions" class="flex flex-col space-y-3">
                        </div>
                    <div id="quizWrittenAnswerArea" class="hidden">
                        <textarea id="quizWrittenAnswerInput" placeholder="Votre réponse ici..."
                                    rows="6" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y"></textarea>
                    </div>
                    <div id="quizMatchingArea" class="hidden">
                        <p class="text-sm text-gray-500 italic mt-2">Les questions de type "relier" ne sont pas encore implémentées dans cette version.</p>
                    </div>
                </div>

                <div class="flex justify-between items-center mt-6">
                    <button id="prevQuestionBtn" class="btn btn-secondary" disabled>← Précédent</button>
                    <div class="flex gap-2">
                        <button id="startQuizTimerBtn" class="btn btn-success">▶️ Démarrer le Quiz</button>
                        <button id="nextQuestionBtn" class="btn btn-primary hidden">Suivant →</button>
                        <button id="submitQuizBtn" class="btn btn-primary hidden">✓ Terminer le Quiz</button>
                    </div>
                </div>
                <div class="flex justify-center mt-4">
                    <button id="saveAndQuitQuizBtn" class="btn btn-secondary">💾 Sauvegarder et Quitter</button>
                </div>


                <div id="quizEvaluationArea" class="hidden mt-8 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                    <h4 class="text-lg font-semibold text-gray-700 mb-2">Résultats du Quiz :</h4>
                    <div id="quizResultsSummary" class="text-gray-800 mb-4 document-content-display"></div>
                    
                    <h4 class="text-lg font-semibold text-gray-700 mb-2">Évaluation Détaillée de l'IA :</h4>
                    <div id="quizAIEvaluation" class="text-gray-800 mb-4 document-content-display bg-blue-50 border-blue-200"></div>
                    <div id="quizCorrectionContent" class="text-gray-800 mb-4 document-content-display bg-green-50 border-green-200"></div>

                    <div class="flex justify-end gap-4 mt-6">
                        <button id="closeQuizResultsBtn" class="btn btn-secondary">Fermer</button>
                        <button id="reEvaluateUnderstandingBtn" class="btn btn-primary hidden">Évaluer ma compréhension (1-5)</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modale de correction (non utilisée directement par le quiz interactif actuel) -->
    <div id="correctionModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Corrigé pour : <span id="correctionDocumentName" class="font-bold text-blue-600"></span></h3>
            <div id="correctionLoading" class="flex justify-center items-center py-8 hidden">
                <div class="loading-spinner"></div>
                <p class="ml-4 text-gray-600">Génération du corrigé par l'IA...</p>
            </div>
            <div id="correctionContent" class="document-content-display"></div>
            <div class="flex justify-end gap-4 mt-6">
                <button id="closeCorrectionBtn" class="btn btn-primary">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modale de gestion des catégories -->
    <div id="categoryManagementModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Gérer les Catégories et Sous-catégories</h3>
            <div class="mb-4">
                <h4 class="text-lg font-semibold text-gray-700 mb-2">Ajouter une nouvelle catégorie</h4>
                <div class="flex gap-2">
                    <input type="text" id="newCategoryNameInput" placeholder="Nom de la catégorie" class="p-2 border rounded-lg flex-grow">
                    <button id="addCategoryBtn" class="btn btn-primary">➕ Ajouter</button>
                </div>
            </div>
            <div class="mb-4">
                <h4 class="text-lg font-semibold text-gray-700 mb-2">Catégories existantes</h4>
                <ul id="categoriesList" class="space-y-3">
                    </ul>
            </div>
            <div class="flex justify-end gap-4">
                <button id="closeCategoryManagementBtn" class="btn btn-secondary">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modale de confirmation personnalisée -->
    <div id="confirmModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4" id="confirmTitle">Confirmer</h3>
            <p class="text-gray-600 mb-6" id="confirmMessage">Êtes-vous sûr ?</p>
            <div class="flex justify-end gap-4">
                <button id="cancelConfirmBtn" class="btn btn-secondary">Annuler</button>
                <button id="okConfirmBtn" class="btn btn-danger">Confirmer</button>
            </div>
        </div>
    </div>

    <!-- Modale d'alerte personnalisée -->
    <div id="customAlertModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4" id="alertTitle">Alerte</h3>
            <p class="text-gray-600 mb-6" id="alertMessage">Ceci est un message d'alerte.</p>
            <div class="flex justify-end">
                <button id="closeAlertBtn" class="btn btn-primary">OK</button>
            </div>
        </div>
    </div>

    <!-- Modale pour les Flashcards -->
    <div id="flashcardModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Flashcards</h3>
            <div id="flashcardLoading" class="flex justify-center items-center py-8 hidden">
                <div class="loading-spinner"></div>
                <p class="ml-4 text-gray-600">Génération des flashcards par l'IA...</p>
            </div>
            <div class="flashcard-wrapper mb-6">
                <div id="flashcardCard" class="flashcard-card">
                    <div id="flashcardFront" class="flashcard-front">
                        <div id="flashcardQuestionDisplay" class="flashcard-text-content"></div>
                    </div>
                    <div id="flashcardBack" class="flashcard-back">
                        <div id="flashcardAnswerDisplay" class="flashcard-text-content"></div>
                    </div>
                </div>
            </div>
            <div class="flex justify-center gap-4 mb-6">
                <button id="flipFlashcardBtn" class="btn btn-warning">🔄 Retourner</button>
            </div>
            <div class="flex flex-col sm:flex-row justify-between items-center mb-6 gap-2">
                <button id="prevFlashcardBtn" class="btn btn-secondary mobile-full-width">← Précédent</button>
                <span class="text-gray-700 text-center">Flashcard <span id="currentFlashcardIndexDisplay">0</span>/<span id="totalFlashcardsDisplay">0</span></span>
                <button id="nextFlashcardBtn" class="btn btn-secondary mobile-full-width">Suivant →</button>
            </div>

            <!-- New: Flashcard Generation and Management Controls -->
            <div class="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                <h4 class="text-lg font-semibold text-blue-800 mb-3">Générer/Gérer les Flashcards</h4>
                <div class="flex flex-col gap-3">
                    <div>
                        <label for="numFlashcardsToGenerateInput" class="block text-sm font-medium text-gray-700 mb-1">Nombre de flashcards à générer (laissez vide pour l'IA) :</label>
                        <input type="number" id="numFlashcardsToGenerateInput" placeholder="Ex: 10" min="1" class="p-2 border rounded-lg w-full">
                    </div>
                    <button id="generateFlashcardsWithAIButton" class="btn btn-primary">✨ Générer via IA</button>
                    <button id="openManageFlashcardsModalButton" class="btn btn-secondary">⚙️ Gérer Manuellement</button>
                </div>
            </div>
            <!-- End New -->

            <div class="flex justify-end">
                <button id="closeFlashcardModalBtn" class="btn btn-primary">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modale de gestion des Flashcards (ajout/édition) -->
    <div id="manageFlashcardsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Gérer les Flashcards pour : <span id="manageFlashcardsDocumentName" class="font-bold text-blue-600"></span></h3>

            <div class="mb-4">
                <h4 class="text-lg font-semibold text-gray-700 mb-2">Ajouter une nouvelle Flashcard</h4>
                <div class="flex flex-col gap-2">
                    <input type="text" id="newFlashcardQuestionInput" placeholder="Question de la flashcard" class="p-2 border rounded-lg">
                    <textarea id="newFlashcardAnswerInput" placeholder="Réponse de la flashcard" rows="3" class="p-2 border rounded-lg resize-y"></textarea>
                    <button id="addFlashcardManuallyBtn" class="btn btn-primary">➕ Ajouter Manuellement</button>
                </div>
            </div>

            <div class="mb-4">
                <h4 class="text-lg font-semibold text-gray-700 mb-2">Flashcards Existantes</h4>
                <ul id="flashcardsManagementList" class="space-y-3">
                    <!-- Flashcards will be listed here -->
                </ul>
            </div>

            <div class="flex justify-end gap-4">
                <button id="closeManageFlashcardsModalBtn" class="btn btn-secondary">Fermer</button>
            </div>
        </div>
    </div>

    <script>
        // Fonction utilitaire pour formater les dates
        function formatDate(dateString) {
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return new Date(dateString).toLocaleDateString('fr-FR', options);
        }

        // Fonction utilitaire pour formater le temps en HH:MM:SS
        function formatTime(seconds) {
            const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
            const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
            const s = String(seconds % 60).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        // Récupérer les éléments du DOM
        const documentNameInput = document.getElementById('documentNameInput');
        const documentCategorySelect = document.getElementById('documentCategorySelect');
        const documentSubcategorySelect = document.getElementById('documentSubcategorySelect');
        const documentContentInput = document.getElementById('documentContentInput');
        const addDocumentBtn = document.getElementById('addDocumentBtn');
        const manageCategoriesBtn = document.getElementById('manageCategoriesBtn');
        const documentsDueTodayContainer = document.getElementById('documentsDueToday');
        const noDocumentsDueMessage = document.getElementById('noDocumentsDue');
        const allDocumentsList = document.getElementById('allDocumentsList');
        const noDocumentsYetMessage = document.getElementById('noDocumentsYet');

        // NEW AI Document Action Elements
        const aiDocumentActionSelect = document.getElementById('aiDocumentActionSelect');
        const aiDocumentActionLoading = document.getElementById('aiDocumentActionLoading');

        // Éléments pour la recherche et le filtrage
        const searchDocumentInput = document.getElementById('searchDocumentInput');
        const filterStatusSelect = document.getElementById('filterStatusSelect');
        const filterCategorySelect = document.getElementById('filterCategorySelect');
        const filterSubcategorySelect = document.getElementById('filterSubcategorySelect');

        // Boutons d'import/export
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataBtn = document.getElementById('importDataBtn');
        const importFileInput = document.getElementById('importFileInput');

        // Éléments de la clé API
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');

        // Modale de révision
        const reviewModal = document.getElementById('reviewModal');
        const modalDocumentName = document.getElementById('modalDocumentName');
        const modalDocumentContent = document.getElementById('modalDocumentContent');
        const scoreButtons = document.querySelectorAll('.score-button');
        const cancelReviewBtn = document.getElementById('cancelReviewBtn');
        const submitReviewBtn = document.getElementById('submitReviewBtn');

        // NEW AI Chat elements in reviewModal
        const aiChatDisplay = document.getElementById('aiChatDisplay');
        const aiChatInput = document.getElementById('aiChatInput');
        const sendAIChatBtn = document.getElementById('sendAIChatBtn');
        const aiChatLoading = document.getElementById('aiChatLoading');


        // Modale de configuration du test AI
        const testConfigModal = document.getElementById('testConfigModal');
        const testConfigDocumentName = document.getElementById('testConfigDocumentName');
        const studyLevelInput = document.getElementById('studyLevelInput');
        const difficultyInput = document.getElementById('difficultyInput');
        const questionTypeInput = document.getElementById('questionTypeInput'); 
        const numQuestionsInput = document.getElementById('numQuestionsInput'); 
        const additionalContextInput = document.getElementById('additionalContextInput');
        const cancelTestConfigBtn = document.getElementById('cancelTestConfigBtn');
        const prepareInteractiveTestBtn = document.getElementById('prepareInteractiveTestBtn'); 

        // Modale pour répondre au test AI (Interactive Quiz) - Rénovée
        const doTestModal = document.getElementById('doTestModal');
        const doTestDocumentName = document.getElementById('doTestDocumentName');
        const quizGenerationLoading = document.getElementById('quizGenerationLoading'); 
        const quizDisplayArea = document.getElementById('quizDisplayArea'); 
        const currentQuestionNumber = document.getElementById('currentQuestionNumber'); 
        const totalQuestions = document.getElementById('totalQuestions'); 
        const quizQuestionText = document.getElementById('quizQuestionText'); 
        const quizQuestionOptions = document.getElementById('quizQuestionOptions'); 
        const quizWrittenAnswerArea = document.getElementById('quizWrittenAnswerArea'); 
        const quizWrittenAnswerInput = document.getElementById('quizWrittenAnswerInput'); 
        const quizMatchingArea = document.getElementById('quizMatchingArea'); 
        const prevQuestionBtn = document.getElementById('prevQuestionBtn'); 
        const startQuizTimerBtn = document.getElementById('startQuizTimerBtn'); 
        const nextQuestionBtn = document.getElementById('nextQuestionBtn'); 
        const submitQuizBtn = document.getElementById('submitQuizBtn'); 
        const testTimer = document.getElementById('testTimer');
        const quizEvaluationArea = document.getElementById('quizEvaluationArea'); 
        const quizResultsSummary = document.getElementById('quizResultsSummary'); 
        const quizAIEvaluation = document.getElementById('quizAIEvaluation'); 
        const quizCorrectionContent = document.getElementById('quizCorrectionContent'); 
        const closeQuizResultsBtn = document.getElementById('closeQuizResultsBtn'); 
        const reEvaluateUnderstandingBtn = document.getElementById('reEvaluateUnderstandingBtn'); 
        const saveAndQuitQuizBtn = document.getElementById('saveAndQuitQuizBtn'); 

        const aiTestsSavedList = document.getElementById('aiTestsSavedList');
        const noAITestsSavedMessage = document.getElementById('noAITestsSaved');

        // Modale du corrigé
        const correctionModal = document.getElementById('correctionModal');
        const correctionDocumentName = document.getElementById('correctionDocumentName');
        const correctionLoading = document.getElementById('correctionLoading');
        const correctionContent = document.getElementById('correctionContent');
        const closeCorrectionBtn = document.getElementById('closeCorrectionBtn');

        // Modale de gestion des catégories
        const categoryManagementModal = document.getElementById('categoryManagementModal');
        const newCategoryNameInput = document.getElementById('newCategoryNameInput');
        const addCategoryBtn = document.getElementById('addCategoryBtn');
        const categoriesList = document.getElementById('categoriesList');
        const closeCategoryManagementBtn = document.getElementById('closeCategoryManagementBtn');

        // Modale de confirmation personnalisée
        const confirmModal = document.getElementById('confirmModal');
        const confirmTitle = document.getElementById('confirmTitle');
        const confirmMessage = document.getElementById('confirmMessage');
        const cancelConfirmBtn = document.getElementById('cancelConfirmBtn');
        const okConfirmBtn = document.getElementById('okConfirmBtn');

        // Modale d'alerte personnalisée
        const customAlertModal = document.getElementById('customAlertModal');
        const alertTitle = document.getElementById('alertTitle');
        const alertMessage = document.getElementById('alertMessage');
        const closeAlertBtn = document.getElementById('closeAlertBtn');

        // Flashcard elements
        const flashcardModal = document.getElementById('flashcardModal');
        const flashcardCard = document.getElementById('flashcardCard'); // NEW
        const flashcardFront = document.getElementById('flashcardFront'); // NEW
        const flashcardBack = document.getElementById('flashcardBack'); // NEW
        const flashcardQuestionDisplay = document.getElementById('flashcardQuestionDisplay');
        const flashcardAnswerDisplay = document.getElementById('flashcardAnswerDisplay');
        const flipFlashcardBtn = document.getElementById('flipFlashcardBtn');
        const prevFlashcardBtn = document.getElementById('prevFlashcardBtn');
        const nextFlashcardBtn = document.getElementById('nextFlashcardBtn');
        const currentFlashcardIndexDisplay = document.getElementById('currentFlashcardIndexDisplay');
        const totalFlashcardsDisplay = document.getElementById('totalFlashcardsDisplay');
        const closeFlashcardModalBtn = document.getElementById('closeFlashcardModalBtn');
        const flashcardLoading = document.getElementById('flashcardLoading');

        // NEW Flashcard Management Elements
        const manageFlashcardsModal = document.getElementById('manageFlashcardsModal');
        const manageFlashcardsDocumentName = document.getElementById('manageFlashcardsDocumentName');
        const newFlashcardQuestionInput = document.getElementById('newFlashcardQuestionInput');
        const newFlashcardAnswerInput = document.getElementById('newFlashcardAnswerInput');
        const addFlashcardManuallyBtn = document.getElementById('addFlashcardManuallyBtn');
        const flashcardsManagementList = document.getElementById('flashcardsManagementList');
        const closeManageFlashcardsModalBtn = document.getElementById('closeManageFlashcardsModalBtn');
        const numFlashcardsToGenerateInput = document.getElementById('numFlashcardsToGenerateInput'); // New input for number of flashcards
        const generateFlashcardsWithAIButton = document.getElementById('generateFlashcardsWithAIButton'); // Button to trigger generation with count
        const openManageFlashcardsModalButton = document.getElementById('openManageFlashcardsModalButton'); // Button to open manage flashcards modal


        let currentFlashcards = [];
        let currentFlashcardIndex = 0;
        let isFlashcardFlipped = false;
        let currentManagingDocumentId = null; // To track which document's flashcards are being managed


        let documents = [];
        let categories = [];

        let currentReviewingDocumentId = null;
        let selectedScore = null;
        let currentDocumentForTest = null; 
        let currentAITestBeingAnswered = null; 
        let timerInterval;
        let secondsElapsed = 0;

        let currentQuestionIndex = 0; 

        let editingDocumentId = null; // New global variable to track document being edited


        // API Key pour Gemini (sera chargée depuis localStorage)
        let apiKey = ""; 

        /**
         * Charge la clé API Gemini depuis le localStorage.
         */
        function loadApiKeyFromLocalStorage() {
            const storedApiKey = localStorage.getItem('geminiApiKey');
            if (storedApiKey) {
                apiKey = storedApiKey;
                apiKeyInput.value = storedApiKey;
                console.log("Clé API chargée depuis localStorage.");
            } else {
                console.log("Aucune clé API trouvée dans localStorage.");
            }
        }

        /**
         * Affiche une modale d'alerte personnalisée.
         * @param {string} message Le message à afficher dans l'alerte.
         * @param {string} [title='Alerte'] Le titre de l'alerte.
         * @param {string} [type='info'] Le type d'alerte ('info', 'success', 'error', 'warning').
         */
        function showAlert(message, title = 'Alerte', type = 'info') {
            alertTitle.textContent = title;
            alertMessage.textContent = message;
            customAlertModal.classList.remove('hidden');

            const alertParagraph = customAlertModal.querySelector('#alertMessage');
            alertParagraph.className = 'text-gray-600 mb-6';
            const alertClasses = ['alert-message'];
            if (type === 'success') {
                alertClasses.push('alert-success');
            } else if (type === 'error') {
                alertClasses.push('alert-error');
            } else if (type === 'warning') {
                alertClasses.push('alert-warning');
            } else {
                alertClasses.push('alert-info');
            }
            alertParagraph.className = alertClasses.join(' ');
        }

        /**
         * Affiche une modale de confirmation personnalisée.
         * @param {string} message Le message de confirmation.
         * @param {string} [title='Confirmer'] Le titre de la modale.
         * @returns {Promise<boolean>} Une promesse qui se résout à true si confirmé, false sinon.
         */
        function showConfirm(message, title = 'Confirmer') {
            return new Promise((resolve) => {
                confirmTitle.textContent = title;
                confirmMessage.textContent = message;
                confirmModal.classList.remove('hidden');

                const handleConfirm = () => {
                    confirmModal.classList.add('hidden');
                    okConfirmBtn.removeEventListener('click', handleConfirm);
                    cancelConfirmBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                const handleCancel = () => {
                    confirmModal.classList.add('hidden');
                    okConfirmBtn.removeEventListener('click', handleConfirm);
                    cancelConfirmBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                okConfirmBtn.addEventListener('click', handleConfirm);
                cancelConfirmBtn.addEventListener('click', handleCancel);
            });
        }

        function loadDocuments() {
            try {
                const storedDocs = localStorage.getItem('forgettingCurveDocuments');
                if (storedDocs) {
                    documents = JSON.parse(storedDocs);
                    documents.forEach(doc => {
                        doc.lastReviewed = new Date(doc.lastReviewed);
                        doc.nextReview = new Date(doc.nextReview);
                        doc.category = doc.category || 'Non classé';
                        doc.subcategory = doc.subcategory || 'Non classé';

                        if (doc.aiTests) {
                            doc.aiTests.forEach(test => {
                                test.generatedAt = new Date(test.generatedAt);
                                if (test.startTime) test.startTime = new Date(test.startTime);
                                if (test.endTime) test.endTime = new Date(test.endTime);
                                test.config = test.config || {}; 
                                test.config.difficulty = test.config.difficulty || 'Moyen';
                                test.config.questionType = test.config.questionType || 'qcm'; 
                                test.config.numQuestions = test.config.numQuestions || 5; 
                                test.currentQuestionIndex = test.currentQuestionIndex !== undefined ? test.currentQuestionIndex : 0;
                                if (typeof test.content === 'string' && !test.structuredContent) {
                                    test.structuredContent = null; 
                                }
                                delete test.config.generalTheme;
                                delete test.config.specificTheme;
                            });
                        }
                        doc.aiChatHistory = doc.aiChatHistory || [];
                        doc.flashcards = doc.flashcards || []; 
                        // Removed synthesis related initialization
                    });
                }

                const storedCategories = localStorage.getItem('rvsionCategories');
                if (storedCategories) {
                    categories = JSON.parse(storedCategories);
                }
            } catch (e) {
                console.error("Erreur lors du chargement des données depuis localStorage:", e);
                showAlert("Impossible de charger les données. Le stockage local est peut-être bloqué ou corrompu. Assurez-vous d'accéder à l'application via un serveur HTTP.", "Erreur de chargement des données", "error");
                documents = [];
                categories = [];
            }
            populateCategorySelectors();
            populateFilterCategorySelectors();
            renderDocuments();
            renderAITests();
            initGlobalEventListeners(); 
        }

        function saveDocuments() {
            try {
                localStorage.setItem('forgettingCurveDocuments', JSON.stringify(documents));
                localStorage.setItem('rvsionCategories', JSON.stringify(categories));
            } catch (e) {
                console.error("Erreur lors de la sauvegarde des données dans localStorage:", e);
                showAlert("Impossible de sauvegarder les données. Le stockage local est peut-être bloqué ou plein. Vos changements pourraient ne pas être conservés.", "Erreur de sauvegarde des données", "warning");
            }
        }

        function calculateNextReview(doc, q) {
            let ef = doc.easeFactor;
            let n = doc.consecutiveSuccessfulReviews;
            let interval = doc.currentInterval;

            if (q >= 3) {
                if (n === 0) {
                    interval = 1;
                } else if (n === 1) {
                    interval = 6;
                } else {
                    interval = Math.round(interval * ef);
                }
                n++;
            } else {
                n = 0;
                interval = 1;
            }

            ef = ef + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02));
            if (ef < 1.3) {
                ef = 1.3;
            }

            doc.easeFactor = ef;
            doc.consecutiveSuccessfulReviews = n;
            doc.currentInterval = interval;
            doc.lastReviewed = new Date();

            const nextReviewDate = new Date();
            nextReviewDate.setDate(nextReviewDate.getDate() + interval);
            doc.nextReview = nextReviewDate;
            saveDocuments();
        }

        function renderDocuments() {
            documentsDueTodayContainer.innerHTML = '';
            allDocumentsList.innerHTML = '';
            noDocumentsDueMessage.style.display = 'none';
            noDocumentsYetMessage.style.display = 'none';

            if (documents.length === 0) {
                noDocumentsYetMessage.style.display = 'block';
                noDocumentsDueMessage.style.display = 'block';
                return;
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let documentsDueCount = 0;
            const searchTerm = searchDocumentInput.value.toLowerCase();
            const filterStatus = filterStatusSelect.value;
            const filterCategory = filterCategorySelect.value === 'all' ? null : categories.find(cat => cat.id === filterCategorySelect.value)?.name;
            const filterSubcategory = filterSubcategorySelect.value === 'all' ? null : categories.find(cat => cat.id === filterCategorySelect.value)?.subcategories.find(sub => sub.id === filterSubcategorySelect.value)?.name;

            const filteredDocuments = documents.filter(doc => {
                const matchesSearch = doc.name.toLowerCase().includes(searchTerm) || 
                                        doc.content.toLowerCase().includes(searchTerm) ||
                                        (doc.category && doc.category.toLowerCase().includes(searchTerm)) || 
                                        (doc.subcategory && doc.subcategory.toLowerCase().includes(searchTerm)); 
                
                const nextReviewDate = new Date(doc.nextReview);
                nextReviewDate.setHours(0, 0, 0, 0);
                const isDueToday = nextReviewDate <= today;

                let matchesStatus = true;
                if (filterStatus === 'due') {
                    matchesStatus = isDueToday;
                } else if (filterStatus === 'not-due') {
                    matchesStatus = !isDueToday;
                }

                let matchesCategory = true;
                if (filterCategory) {
                    matchesCategory = doc.category === filterCategory;
                }

                let matchesSubcategory = true;
                if (filterSubcategory) {
                    matchesSubcategory = doc.subcategory === filterSubcategory;
                }

                return matchesSearch && matchesStatus && matchesCategory && matchesSubcategory;
            });

            if (filteredDocuments.length === 0 && (searchTerm.length > 0 || filterStatus !== 'all' || filterCategory !== null || filterSubcategory !== null)) {
                allDocumentsList.innerHTML = '<p class="text-gray-600 italic">Aucun document ne correspond à vos critères de recherche/filtre.</p>';
            } else if (filteredDocuments.length === 0 && searchTerm.length === 0 && filterStatus === 'all' && filterCategory === null && filterSubcategory === null) {
                    noDocumentsYetMessage.style.display = 'block';
                    allDocumentsList.innerHTML = ''; 
            } else if (filteredDocuments.length === 0) {
                allDocumentsList.innerHTML = '<p class="text-gray-600 italic">Aucun document ne correspond à vos critères de recherche/filtre.</p>';
            }

            filteredDocuments.forEach(doc => {
                const nextReviewDate = new Date(doc.nextReview);
                nextReviewDate.setHours(0, 0, 0, 0);

                const isDueToday = nextReviewDate <= today;

                const card = document.createElement('div');
                card.className = `p-4 rounded-lg shadow-md flex flex-col justify-between ${isDueToday ? 'bg-blue-100 border border-blue-300' : 'bg-white border border-gray-200'}`;
                card.innerHTML = `
                    <h3 class="text-lg font-semibold mb-2 text-gray-900">${doc.name}</h3>
                    <p class="text-sm text-gray-600">Catégorie: ${doc.category || 'Non classé'} | Sous-catégorie: ${doc.subcategory || 'Non classé'}</p>
                    <p class="text-sm text-gray-600">Dernière révision: ${formatDate(doc.lastReviewed)}</p>
                    <p class="text-sm text-gray-600">Prochaine révision: <span class="font-medium ${isDueToday ? 'text-blue-700' : 'text-gray-700'}">${formatDate(doc.nextReview)}</span></p>
                    <p class="text-xs text-gray-500 mt-1">EF: ${doc.easeFactor.toFixed(2)} | Intervalle: ${doc.currentInterval} jours | Révisions réussies: ${doc.consecutiveSuccessfulReviews}</p>
                    <div class="mt-4 flex justify-end gap-2 flex-wrap">
                        <button data-id="${doc.id}" class="btn btn-success review-btn">📝 Réviser</button>
                        <button data-id="${doc.id}" class="btn btn-warning test-ai-btn">✨ Test (IA)</button>
                        <button data-id="${doc.id}" class="btn btn-info flashcards-btn">🗂️ Flashcards</button>
                        <button data-id="${doc.id}" class="btn btn-info edit-document-btn">✏️ Modifier</button>
                        <button data-id="${doc.id}" class="btn btn-danger delete-btn">🗑️ Supprimer</button>
                    </div>
                `;

                if (isDueToday) {
                    documentsDueTodayContainer.appendChild(card.cloneNode(true));
                    documentsDueCount++;
                }
                allDocumentsList.appendChild(card);
            });

            if (documentsDueCount === 0) {
                noDocumentsDueMessage.style.display = 'block';
            } else {
                noDocumentsDueMessage.style.display = 'none';
            }
            if (documents.length > 0) {
                noDocumentsYetMessage.style.display = 'none';
            }

            addDocumentEventListeners();
        }

        function renderAITests() {
            aiTestsSavedList.innerHTML = '';
            noAITestsSavedMessage.style.display = 'block';

            let aiTestsCount = 0;
            documents.forEach(doc => {
                if (doc.aiTests && doc.aiTests.length > 0) {
                    // Sort tests by generation date, newest first
                    doc.aiTests.sort((a, b) => new Date(b.generatedAt) - new Date(a.generatedAt));

                    doc.aiTests.forEach(aiTest => {
                        // N'afficher que les tests 'pending' ou 'in_progress' ou 'completed'
                        if (aiTest.status === 'pending' || aiTest.status === 'in_progress' || aiTest.status === 'completed') {
                            noAITestsSavedMessage.style.display = 'none';
                            aiTestsCount++;
                            const testCard = document.createElement('div');
                            testCard.className = `p-4 rounded-lg shadow-md flex flex-col justify-between bg-purple-100 border border-purple-300`;
                            
                            let statusText = '';
                            let statusClass = '';
                            if (aiTest.status === 'pending') {
                                statusText = 'En attente';
                                statusClass = 'text-purple-700';
                            } else if (aiTest.status === 'in_progress') {
                                statusText = 'En cours';
                                statusClass = 'text-orange-700';
                            } else if (aiTest.status === 'completed') {
                                statusText = 'Terminé';
                                statusClass = 'text-green-700';
                            }

                            let durationText = aiTest.duration ? `Durée: ${formatTime(aiTest.duration)}` : '';
                            let scoreText = aiTest.aiScore ? `Note AI: ${aiTest.aiScore}/5` : '';
                            let typeText = '';
                            if (aiTest.config.questionType === 'qcm') typeText = ' (QCM)';
                            else if (aiTest.config.questionType === 'written') typeText = ' (Écrit)';
                            else if (aiTest.config.questionType === 'mixed') typeText = ' (Mixte)';
                            else typeText = ' (Interactif)';


                            testCard.innerHTML = `
                                <h3 class="text-lg font-semibold mb-2 text-gray-900">Test AI pour : ${doc.name}</h3>
                                <p class="text-sm text-gray-600">Type: ${typeText} | Questions: ${aiTest.structuredContent?.questions?.length || 'N/A'} | Généré: ${formatDate(aiTest.generatedAt)}</p>
                                <p class="text-sm text-gray-600">Difficulté: ${aiTest.config.difficulty || 'Non spécifiée'} | Niveau: ${aiTest.config.studyLevel || 'Non spécifié'}</p>
                                <p class="text-xs text-gray-500 mt-1">Statut: <span class="font-bold ${statusClass}">${statusText}</span> ${durationText ? `| ${durationText}` : ''} ${scoreText ? `| ${scoreText}` : ''}</p>
                                <div class="mt-4 flex justify-end gap-2">
                                    <button data-doc-id="${doc.id}" data-test-id="${aiTest.id}" class="btn btn-primary do-ai-test-btn">▶️ Répondre au Test</button>
                                    <button data-doc-id="${doc.id}" data-test-id="${aiTest.id}" class="btn btn-danger delete-ai-test-btn">🗑️ Supprimer</button>
                                </div>
                            `;
                            aiTestsSavedList.appendChild(testCard);
                        }
                    });
                }
            });

            if (aiTestsCount === 0) {
                noAITestsSavedMessage.style.display = 'block';
            }
            addAITestEventListeners();
        }

        function populateCategorySelectors() {
            documentCategorySelect.innerHTML = '<option value="">Sélectionner une catégorie</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                documentCategorySelect.appendChild(option);
            });
            documentSubcategorySelect.innerHTML = '<option value="">Sélectionner une sous-catégorie</option>';
            documentSubcategorySelect.disabled = true;
        }

        function populateFilterCategorySelectors() {
            filterCategorySelect.innerHTML = '<option value="all">Toutes catégories</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                filterCategorySelect.appendChild(option);
            });
            filterSubcategorySelect.innerHTML = '<option value="all">Toutes sous-catégories</option>';
            filterSubcategorySelect.disabled = true;
        }
        
        addDocumentBtn.addEventListener('click', async () => {
            try {
                // Vérifier si la clé API est présente
                if (!apiKey) {
                    showAlert("Veuillez d'abord sauvegarder votre clé API Gemini. Le traitement AI ne fonctionnera pas sans elle.", "Clé API manquante", "warning");
                    return;
                }

                const name = documentNameInput.value.trim();
                const selectedCategoryId = documentCategorySelect.value;
                const selectedSubcategoryId = documentSubcategorySelect.value;
                let content = documentContentInput.value.trim();
                const aiAction = aiDocumentActionSelect.value;

                if (!name) {
                    showAlert('Veuillez entrer un nom pour le document.', 'Champ vide', 'error');
                    return;
                }
                if (!content && (aiAction === 'none' || aiAction === 'optimize')) {
                    showAlert('Veuillez entrer un contenu pour le document si l\'IA ne doit pas le développer ou l\'optimiser, ou sélectionnez "Développer/Créer le cours".', 'Contenu manquant', 'error');
                    return;
                }

                if (aiAction !== 'none') {
                    aiDocumentActionLoading.classList.remove('hidden');
                    addDocumentBtn.disabled = true;
                    try {
                        content = await processDocumentContentWithAI(content, aiAction, name);
                        documentContentInput.value = content;
                        if (!content) {
                            showAlert("L'IA n'a pas pu générer ou optimiser le contenu. Veuillez réessayer ou ajuster vos entrées.", "Échec de l'IA", "warning");
                            return;
                        }
                    } catch (aiError) {
                        console.error("Erreur lors du traitement AI du document:", aiError);
                        showAlert("Une erreur est survenue lors du traitement AI du document. Veuillez réessayer.", "Erreur AI", "error");
                        return;
                    } finally {
                        aiDocumentActionLoading.classList.add('hidden');
                        addDocumentBtn.disabled = false;
                    }
                }

                let categoryName = 'Non classé';
                let subcategoryName = 'Non classé';

                if (selectedCategoryId) {
                    const category = categories.find(cat => cat.id === selectedCategoryId);
                    if (category) {
                        categoryName = category.name;
                        if (selectedSubcategoryId && selectedSubcategoryId !== "") {
                            const subcategory = category.subcategories.find(sub => sub.id === selectedSubcategoryId);
                            if (subcategory) {
                                subcategoryName = subcategory.name;
                            } else {
                                subcategoryName = 'Non classé';
                            }
                        } else {
                            subcategoryName = 'Non classé';
                        }
                    } else {
                        categoryName = 'Non classé';
                        subcategoryName = 'Non classé';
                    }
                }

                if (editingDocumentId) {
                    // Update existing document
                    const docToUpdate = documents.find(d => d.id === editingDocumentId);
                    if (docToUpdate) {
                        docToUpdate.name = name;
                        docToUpdate.category = categoryName;
                        docToUpdate.subcategory = subcategoryName;
                        docToUpdate.content = content;
                        saveDocuments();
                        renderDocuments();
                        addDocumentBtn.textContent = '➕ Ajouter le document'; // Reset button text
                        showAlert('Document modifié avec succès !', 'Succès', 'success');
                        editingDocumentId = null; // Clear editing state
                        documentNameInput.value = '';
                        documentCategorySelect.value = '';
                        documentSubcategorySelect.innerHTML = '<option value="">Sélectionner une sous-catégorie</option>';
                        documentSubcategorySelect.disabled = true;
                        documentContentInput.value = '';
                        aiDocumentActionSelect.value = 'none';
                    }
                } else {
                    // Add new document
                    const newDoc = {
                        id: crypto.randomUUID(),
                        name: name,
                        category: categoryName,
                        subcategory: subcategoryName,
                        content: content,
                        lastReviewed: new Date().toISOString(),
                        nextReview: new Date().toISOString(),
                        easeFactor: 2.5,
                        consecutiveSuccessfulReviews: 0,
                        currentInterval: 0,
                        aiTests: [],
                        aiChatHistory: [],
                        flashcards: [] 
                    };
                    documents.push(newDoc);
                    saveDocuments();
                    renderDocuments();
                    documentNameInput.value = '';
                    documentCategorySelect.value = '';
                    documentSubcategorySelect.innerHTML = '<option value="">Sélectionner une sous-catégorie</option>';
                    documentSubcategorySelect.disabled = true;
                    documentContentInput.value = '';
                    aiDocumentActionSelect.value = 'none'; 
                    showAlert('Document ajouté avec succès !', 'Succès', 'success');
                }
            } catch (error) {
                console.error("Erreur lors de l'ajout/modification du document:", error);
                showAlert("Une erreur est survenue lors de l'ajout/modification du document. Veuillez consulter la console pour plus de détails.", "Erreur d'ajout/modification", 'error');
            }
        });

        /**
         * Appelle l'IA pour développer, optimiser ou simplifier le contenu d'un document.
         * @param {string} originalContent Le contenu initial du document.
         * @param {string} action L'action AI à effectuer ('develop', 'optimize').
         * @param {string} documentName Le nom du document (pour le contexte de l'IA).
         * @returns {Promise<string>} Le contenu traité par l'IA.
         */
        async function processDocumentContentWithAI(originalContent, action, documentName) {
            // Vérifier si la clé API est définie
            if (!apiKey) {
                throw new Error("Clé API Gemini non configurée. Veuillez la sauvegarder via le champ dédié.");
            }

            let prompt = "";
            if (action === 'develop') {
                prompt = `En tant qu'expert en pédagogie, développez un cours complet et détaillé sur le sujet "${documentName}".
Si un contenu initial est fourni ("${originalContent}"), utilisez-le comme point de départ pour enrichir et structurer le cours.
Le cours doit être clair, bien organisé, et couvrir les aspects essentiels du sujet pour un apprentissage efficace.
Utilisez le formatage Markdown (titres avec #, ##, etc., listes à puces avec -, listes numérotées avec 1., 2., etc., texte en gras avec **). Évitez les astérisques bruts pour les listes.`;
            } else if (action === 'optimize') {
                prompt = `En tant qu'expert en pédagogie, optimisez et simplifiez le contenu suivant pour le rendre plus clair, concis et facile à comprendre.
Adaptez le langage à un niveau général d'apprenant. Reformulez les phrases complexes, supprimez les informations redondantes et structurez le texte pour une meilleure lisibilité.
Utilisez le formatage Markdown (titres avec #, ##, etc., listes à puces avec -, listes numérotées avec 1., 2., etc., texte en gras avec **). Évitez les astérisques bruts pour les listes.
Titre du document : ${documentName}
Contenu à optimiser :
---
${originalContent}
---
Fournissez uniquement le contenu optimisé.`;
            } else {
                return originalContent;
            }

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.error('Erreur API lors du traitement AI du document:', response.status, response.statusText, errorData);
                throw new Error(`Échec de l'IA: ${errorData.error?.message || response.statusText}`);
            } else {
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error('Structure de réponse inattendue de l\'API Gemini pour le traitement du document:', result);
                    throw new Error("L'IA a retourné une structure inattendue.");
                }
            }
        }

        // Gérer les écouteurs d'événements pour tous les boutons des documents
        function addDocumentEventListeners() {
            document.querySelectorAll('.review-btn').forEach(button => {
                button.removeEventListener('click', handleReviewButtonClick);
                button.addEventListener('click', handleReviewButtonClick);
            });
            document.querySelectorAll('.test-ai-btn').forEach(button => {
                button.removeEventListener('click', handleTestAIButtonClick);
                button.addEventListener('click', handleTestAIButtonClick);
            });
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteButtonClick);
                button.addEventListener('click', handleDeleteButtonClick);
            });
            // Add listeners for flashcards
            document.querySelectorAll('.flashcards-btn').forEach(button => {
                button.removeEventListener('click', handleFlashcardsButtonClick);
                button.addEventListener('click', handleFlashcardsButtonClick);
            });
            // Add listener for edit document
            document.querySelectorAll('.edit-document-btn').forEach(button => {
                button.removeEventListener('click', handleEditDocumentButtonClick);
                button.addEventListener('click', handleEditDocumentButtonClick);
            });
            // Removed synthesis button listener
        }

        // Gérer les écouteurs d'événements pour les tests AI
        function addAITestEventListeners() {
            document.querySelectorAll('.do-ai-test-btn').forEach(button => {
                button.removeEventListener('click', handleDoAITestButtonClick); 
                button.addEventListener('click', handleDoAITestButtonClick);
            });
            document.querySelectorAll('.delete-ai-test-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteAITestButtonClick); 
                button.addEventListener('click', handleDeleteAITestButtonClick);
            });
        }

        // Gestionnaire pour le bouton "Réviser"
        function handleReviewButtonClick(event) {
            const docId = event.target.dataset.id;
            const doc = documents.find(d => d.id === docId);
            if (doc) {
                currentReviewingDocumentId = docId;
                modalDocumentName.textContent = doc.name;
                // Render Markdown content (if any) or plain text
                const content = doc.content;
                modalDocumentContent.innerHTML = marked.parse(content); 

                reviewModal.classList.remove('hidden');
                scoreButtons.forEach(btn => btn.classList.remove('selected'));
                selectedScore = null;
                submitReviewBtn.disabled = true;

                aiChatDisplay.innerHTML = ''; 
                if (doc.aiChatHistory && doc.aiChatHistory.length > 0) {
                    doc.aiChatHistory.forEach(msg => displayChatMessage(msg.role, msg.text));
                } else {
                    aiChatDisplay.innerHTML = '<p class="text-gray-500 italic text-center">Posez votre première question !</p>';
                }
                aiChatInput.value = ''; 
                aiChatDisplay.scrollTop = aiChatDisplay.scrollHeight; 
            }
        }

        // Gestionnaire pour le bouton "Test (IA)" (Ouvre la modale de configuration)
        function handleTestAIButtonClick(event) {
            // Vérifier si la clé API est présente
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre clé API Gemini. La préparation du test AI ne fonctionnera pas sans elle.", "Clé API manquante", "warning");
                return;
            }

            const docId = event.target.dataset.id;
            const doc = documents.find(d => d.id === docId);
            if (doc) {
                currentDocumentForTest = doc;
                testConfigDocumentName.textContent = doc.name;
                // Réinitialiser les champs de la modale de configuration
                studyLevelInput.value = '';
                difficultyInput.value = 'Moyen'; 
                questionTypeInput.value = 'qcm';
                numQuestionsInput.value = '5'; 
                additionalContextInput.value = '';
                testConfigModal.classList.remove('hidden');
            }
        }

        prepareInteractiveTestBtn.addEventListener('click', async () => {
            // Vérifier si la clé API est présente
            if (!apiKey) {
                showAlert("Clé API Gemini non configurée. Impossible de générer le test AI.", "Clé API manquante", "error");
                return;
            }

            if (!currentDocumentForTest) {
                showAlert("Erreur: Aucun document sélectionné pour préparer le test.", "Erreur", 'error');
                return;
            }

            const numQuestions = parseInt(numQuestionsInput.value);
            if (isNaN(numQuestions) || numQuestions < 1 || numQuestions > 20) {
                showAlert("Veuillez entrer un nombre de questions valide entre 1 et 20.", "Nombre de questions invalide", "error");
                return;
            }

            testConfigModal.classList.add('hidden');
            doTestModal.classList.remove('hidden');

            currentQuestionIndex = 0;
            clearInterval(timerInterval);
            secondsElapsed = 0;
            testTimer.textContent = formatTime(secondsElapsed);
            startQuizTimerBtn.classList.remove('hidden');
            nextQuestionBtn.classList.add('hidden');
            prevQuestionBtn.classList.add('hidden');
            submitQuizBtn.classList.add('hidden');
            saveAndQuitQuizBtn.classList.add('hidden'); 
            quizDisplayArea.classList.add('hidden');
            quizEvaluationArea.classList.add('hidden');
            
            quizGenerationLoading.classList.remove('hidden'); 

            doTestDocumentName.textContent = currentDocumentForTest.name;

            const studyLevel = studyLevelInput.value.trim();
            const difficulty = difficultyInput.value.trim();
            const questionType = questionTypeInput.value; 
            const additionalContext = additionalContextInput.value.trim();

            try {
                let prompt = `En tant qu'expert en pédagogie, créez un quiz interactif basé sur le document suivant.
                Le quiz doit être composé de ${numQuestions} questions.
                `;

                let responseSchema = {
                    type: "OBJECT",
                    properties: {
                        "quizTitle": { "type": "STRING" },
                        "questions": {
                            "type": "ARRAY",
                            "items": {
                                "type": "OBJECT",
                                "properties": {
                                    "id": { "type": "STRING" },
                                    "type": { "type": "STRING", "enum": ["qcm", "written", "matching"] }, 
                                    "text": { "type": "STRING" },
                                    "options": { 
                                        "type": "ARRAY",
                                        "items": {
                                            "type": "OBJECT",
                                            "properties": {
                                                "id": { "type": "STRING" },
                                                "text": { "type": "STRING" }
                                            },
                                            "required": ["id", "text"]
                                        }
                                    },
                                    "correctAnswerId": { "type": "STRING" }, 
                                    "correctAnswerText": { "type": "STRING" } 
                                },
                                "required": ["id", "type", "text"], 
                                "propertyOrdering": ["id", "type", "text", "options", "correctAnswerId", "correctAnswerText"]
                            }
                        }
                    },
                    "required": ["quizTitle", "questions"],
                    "propertyOrdering": ["quizTitle", "questions"]
                };


                if (questionType === 'qcm' || questionType === 'mixed') {
                    prompt += ` Pour les questions à choix multiples (QCM), chaque question doit avoir 4 options de réponse, et une seule doit être correcte. La réponse correcte doit être clairement indiquée par son ID.`;
                }
                if (questionType === 'written' || questionType === 'mixed') {
                    prompt += ` Pour les questions écrites, fournissez la réponse correcte sous forme de texte dans le champ 'correctAnswerText'.`;
                }

                if (questionType === 'qcm') {
                    prompt += ` Toutes les questions doivent être des QCM.`;
                } else if (questionType === 'written') {
                    prompt += ` Toutes les questions doivent être des questions écrites (réponse libre).`;
                } else if (questionType === 'mixed') {
                    prompt += ` Le quiz doit inclure un mélange de questions QCM et de questions écrites.`;
                }


                prompt += `
Titre du document : ${currentDocumentForTest.name}
Catégorie du document : ${currentDocumentForTest.category || 'Non spécifiée'}
Sous-catégorie du document : ${currentDocumentForTest.subcategory || 'Non spécifiée'}
Contenu du document :
---
${currentDocumentForTest.content}
---

Informations supplémentaires pour adapter le test :
Niveau d'étude de l'apprenant : ${studyLevel || 'Non spécifié'}
Niveau de difficulté souhaité pour le test : ${difficulty || 'Moyen'}
Nombre de questions : ${numQuestions}
Contexte ou instructions supplémentaires : ${additionalContext || 'Aucun'}
`; 
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { 
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema 
                    }
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Erreur API lors de la génération du quiz interactif:', response.status, response.statusText, errorData);
                    showAlert(`Erreur lors de la génération du quiz: ${response.status}. Veuillez réessayer. Détails: ${errorData.error?.message || 'Inconnu'}`, 'Erreur AI', 'error');
                    quizGenerationLoading.classList.add('hidden');
                    doTestModal.classList.add('hidden'); 
                } else {
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        try {
                            const quizData = JSON.parse(result.candidates[0].content.parts[0].text);
                            if (quizData.questions && Array.isArray(quizData.questions) && quizData.questions.length > 0) {
                                const newAITest = {
                                    id: crypto.randomUUID(),
                                    generatedAt: new Date().toISOString(),
                                    content: `Test Interactif (${questionTypeInput.value} - ${numQuestions} questions)`, 
                                    structuredContent: quizData, 
                                    config: {
                                        studyLevel: studyLevel,
                                        difficulty: difficulty,
                                        questionType: questionType, 
                                        numQuestions: numQuestions, 
                                        additionalContext: additionalContext,
                                    },
                                    status: 'pending', 
                                    startTime: null,
                                    endTime: null,
                                    duration: null,
                                    userAnswers: Array(quizData.questions.length).fill(null), 
                                    aiEvaluation: null,
                                    aiScore: null,
                                    correction: null,
                                    currentQuestionIndex: 0 
                                };
                                const docIndex = documents.findIndex(d => d.id === currentDocumentForTest.id);
                                if (!documents[docIndex].aiTests) {
                                    documents[docIndex].aiTests = [];
                                }
                                documents[docIndex].aiTests.push(newAITest);
                                saveDocuments();

                                currentAITestBeingAnswered = newAITest; 
                                totalQuestions.textContent = quizData.questions.length; 
                                renderQuestion(currentQuestionIndex); 
                                quizDisplayArea.classList.remove('hidden');
                                saveAndQuitQuizBtn.classList.remove('hidden'); 
                                showAlert('Quiz interactif généré avec succès ! Cliquez sur "Démarrer le Quiz" pour commencer.', 'Succès AI', 'success');
                            } else {
                                showAlert('L\'IA a généré un quiz vide ou mal formaté. Veuillez réessayer.', 'Erreur AI', 'error');
                                doTestModal.classList.add('hidden');
                            }
                        } catch (parseError) {
                            console.error('Erreur lors du parsing JSON du quiz:', parseError);
                            showAlert('L\'IA a retourné un format JSON invalide pour le quiz. Veuillez réessayer.', 'Erreur de format AI', 'error');
                            doTestModal.classList.add('hidden');
                        }
                    } else {
                        console.error('Structure de réponse inattendue de l\'API Gemini pour le quiz:', result);
                        showAlert('La réponse de l\'IA était inattendue pour le quiz. Veuillez réessayer.', 'Erreur AI', 'error');
                        doTestModal.classList.add('hidden');
                    }
                }
            } catch (error) {
                console.error('Erreur lors de l\'appel de l\'API Gemini pour le quiz:', error);
                showAlert('Une erreur est survenue lors de la génération du quiz. Veuillez vérifier votre connexion internet ou réessayer plus tard.', 'Erreur Réseau', 'error');
                doTestModal.classList.add('hidden');
            } finally {
                quizGenerationLoading.classList.add('hidden');
            }
        });

        /**
         * Affiche la question actuelle du quiz interactif.
         * @param {number} index L'index de la question à afficher.
         */
        function renderQuestion(index) {
            const quiz = currentAITestBeingAnswered.structuredContent;
            if (!quiz || !quiz.questions || index < 0 || index >= quiz.questions.length) {
                showAlert("Erreur: Question introuvable.", "Erreur Quiz", "error");
                return;
            }

            const question = quiz.questions[index];
            currentQuestionNumber.textContent = index + 1;
            // Use marked.parse for quiz question text
            quizQuestionText.innerHTML = marked.parse(question.text);
            
            quizQuestionOptions.classList.add('hidden');
            quizWrittenAnswerArea.classList.add('hidden');
            quizMatchingArea.classList.add('hidden');

            if (question.type === 'qcm') {
                quizQuestionOptions.classList.remove('hidden');
                quizQuestionOptions.innerHTML = ''; 
                question.options.forEach(option => {
                    const optionDiv = document.createElement('label');
                    optionDiv.className = 'quiz-option';
                    // Use marked.parse for QCM option text
                    optionDiv.innerHTML = `
                        <input type="radio" name="currentQuestion" value="${option.id}" class="form-radio text-blue-600">
                        <span>${marked.parse(option.text)}</span>
                    `;
                    quizQuestionOptions.appendChild(optionDiv);

                    if (currentAITestBeingAnswered.userAnswers[index] === option.id) {
                        optionDiv.classList.add('selected');
                        optionDiv.querySelector('input').checked = true;
                    }

                    optionDiv.addEventListener('click', () => {
                        if (currentAITestBeingAnswered.status !== 'completed') {
                            quizQuestionOptions.querySelectorAll('.quiz-option').forEach(opt => opt.classList.remove('selected'));
                            optionDiv.classList.add('selected');
                            optionDiv.querySelector('input').checked = true;
                            currentAITestBeingAnswered.userAnswers[index] = option.id;
                            currentAITestBeingAnswered.currentQuestionIndex = index;
                            saveDocuments(); 
                        }
                    });
                });
            } else if (question.type === 'written') {
                quizWrittenAnswerArea.classList.remove('hidden');
                quizWrittenAnswerInput.value = currentAITestBeingAnswered.userAnswers[index] || ''; 
                quizWrittenAnswerInput.oninput = (event) => {
                    if (currentAITestBeingAnswered.status !== 'completed') {
                        currentAITestBeingAnswered.userAnswers[index] = event.target.value;
                        currentAITestBeingAnswered.currentQuestionIndex = index;
                        saveDocuments();
                    }
                };
            } else if (question.type === 'matching') {
                quizMatchingArea.classList.remove('hidden');
            } else {
                quizQuestionText.textContent = `Type de question "${question.type}" non supporté pour l'instant.`;
            }

            prevQuestionBtn.disabled = (index === 0);
            nextQuestionBtn.classList.toggle('hidden', index === quiz.questions.length - 1);
            submitQuizBtn.classList.toggle('hidden', index !== quiz.questions.length - 1);

            if (currentAITestBeingAnswered.status === 'completed') {
                quizQuestionOptions.querySelectorAll('input').forEach(input => input.disabled = true);
                quizWrittenAnswerInput.disabled = true;
                saveAndQuitQuizBtn.classList.add('hidden'); 
            } else {
                quizWrittenAnswerInput.disabled = false;
            }
        }

        function handleDoAITestButtonClick(event) {
            // Vérifier si la clé API est présente
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre clé API Gemini. Le test AI ne fonctionnera pas sans elle.", "Clé API manquante", "warning");
                return;
            }

            const docId = event.target.dataset.docId;
            const testId = event.target.dataset.testId;

            const doc = documents.find(d => d.id === docId);
            if (doc && doc.aiTests) {
                const aiTest = doc.aiTests.find(test => test.id === testId);
                if (aiTest) {
                    currentAITestBeingAnswered = aiTest;
                    currentDocumentForTest = doc; 

                    doTestDocumentName.textContent = doc.name;
                    
                    quizGenerationLoading.classList.add('hidden');

                    if (aiTest.structuredContent) { 
                        quizDisplayArea.classList.remove('hidden');
                        quizEvaluationArea.classList.add('hidden'); 
                        totalQuestions.textContent = aiTest.structuredContent.questions.length;
                        
                        currentQuestionIndex = aiTest.currentQuestionIndex !== undefined ? aiTest.currentQuestionIndex : 0;
                        renderQuestion(currentQuestionIndex);

                        clearInterval(timerInterval);
                        secondsElapsed = aiTest.duration || 0; 
                        testTimer.textContent = formatTime(secondsElapsed);
                        
                        // Reset button states
                        startQuizTimerBtn.classList.remove('hidden');
                        startQuizTimerBtn.textContent = '▶️ Démarrer le Quiz'; // Default text
                        nextQuestionBtn.classList.add('hidden');
                        prevQuestionBtn.classList.add('hidden');
                        submitQuizBtn.classList.add('hidden');
                        saveAndQuitQuizBtn.classList.remove('hidden'); 

                        if (aiTest.status === 'in_progress') {
                            startQuizTimerBtn.textContent = '▶️ Reprendre le Quiz'; // Change text for resuming
                            // Show nav/submit buttons according to current question index and total questions
                            if (aiTest.structuredContent.questions.length > 1) {
                                nextQuestionBtn.classList.remove('hidden');
                                prevQuestionBtn.classList.remove('hidden');
                            }
                            if (currentQuestionIndex === aiTest.structuredContent.questions.length - 1) {
                                submitQuizBtn.classList.remove('hidden');
                                nextQuestionBtn.classList.add('hidden');
                            }
                            // Don't auto-start timer, user must click "Reprendre"
                            showAlert('Quiz interactif en cours. Cliquez sur "Reprendre le Quiz" pour continuer.', 'Reprise du Quiz', 'info');

                        } else if (aiTest.status === 'completed') {
                            testTimer.textContent = formatTime(aiTest.duration || 0);
                            startQuizTimerBtn.classList.add('hidden');
                            nextQuestionBtn.classList.add('hidden');
                            prevQuestionBtn.classList.add('hidden');
                            submitQuizBtn.classList.add('hidden');
                            saveAndQuitQuizBtn.classList.add('hidden'); 
                            quizQuestionOptions.querySelectorAll('input').forEach(input => input.disabled = true); 
                            quizWrittenAnswerInput.disabled = true;

                            quizEvaluationArea.classList.remove('hidden');
                            if (aiTest.aiEvaluation) {
                                const aiResponseText = aiTest.aiEvaluation;
                                const scoreMatch = aiResponseText.match(/Score Final:\s*(\d+)\/(\d+)/); 
                                const noteMatch = aiResponseText.match(/Note de Compréhension \(1-5\):\s*(\d)\/5/);
                                const evaluationMatch = aiResponseText.match(/Évaluation de l'IA:\s*([\s\S]*?)(?=Corrigé Détaillé:|$)/);
                                const correctionMatch = aiResponseText.match(/Corrigé Détaillé:\s*([\s\S]*)/);

                                let scoreFinal = scoreMatch ? `${scoreMatch[1]}/${scoreMatch[2]}` : 'N/A';
                                let noteComprehension = noteMatch ? parseInt(noteMatch[1]) : 'N/A';
                                let evaluationContent = evaluationMatch ? evaluationMatch[1].trim() : 'Non disponible.';
                                let correctionContent = correctionMatch ? correctionMatch[1].trim() : 'Non disponible.';

                                quizResultsSummary.innerHTML = marked.parse(`**Score Final:** ${scoreFinal} | **Note de Compréhension:** ${noteComprehension}/5`);
                                quizAIEvaluation.innerHTML = marked.parse(evaluationContent);
                                quizCorrectionContent.innerHTML = marked.parse(correctionContent);
                                quizAIEvaluation.classList.remove('hidden');
                                quizCorrectionContent.classList.remove('hidden');
                                reEvaluateUnderstandingBtn.classList.remove('hidden');
                            } else {
                                quizResultsSummary.textContent = "Résultats de l'évaluation AI non disponibles.";
                            }
                            showAlert('Ce quiz est déjà terminé. Durée : ' + formatTime(aiTest.duration || 0), 'Quiz Terminé', 'info');
                        } else { 
                            // Status 'pending'
                            startQuizTimerBtn.textContent = '▶️ Démarrer le Quiz'; // Ensure it says Start
                            saveAndQuitQuizBtn.classList.remove('hidden'); // Ensure visible
                        }
                    } else { 
                        showAlert("Ce test est un ancien format texte. Veuillez utiliser la fonctionnalité de révision pour le document lié si vous souhaitez le revoir.", "Ancien format de test", "warning");
                        doTestModal.classList.add('hidden'); 
                    }
                    doTestModal.classList.remove('hidden');
                }
            }
        }


        // Navigation Suivant / Précédent
        nextQuestionBtn.addEventListener('click', () => {
            if (currentQuestionIndex < currentAITestBeingAnswered.structuredContent.questions.length - 1) {
                currentQuestionIndex++;
                renderQuestion(currentQuestionIndex);
            }
        });

        prevQuestionBtn.addEventListener('click', () => {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                renderQuestion(currentQuestionIndex);
            }
        });

        // Démarrer ou Reprendre le minuteur du quiz
        startQuizTimerBtn.addEventListener('click', () => {
            if (currentAITestBeingAnswered) {
                startQuizTimerBtn.classList.add('hidden');
                saveAndQuitQuizBtn.classList.remove('hidden'); 
                if (currentAITestBeingAnswered.status !== 'in_progress') {
                    currentAITestBeingAnswered.status = 'in_progress';
                    currentAITestBeingAnswered.startTime = new Date().toISOString();
                }
                timerInterval = setInterval(updateTimer, 1000);
                saveDocuments();
                if (currentAITestBeingAnswered.structuredContent.questions.length > 1) {
                    nextQuestionBtn.classList.remove('hidden');
                    prevQuestionBtn.classList.remove('hidden');
                }
                if (currentQuestionIndex === currentAITestBeingAnswered.structuredContent.questions.length - 1) {
                    submitQuizBtn.classList.remove('hidden');
                    nextQuestionBtn.classList.add('hidden');
                }
                showAlert('Quiz démarré/repris ! Bonne chance.', 'Quiz En Cours', 'info');
            }
        });

        // Mettre à jour le minuteur
        function updateTimer() {
            secondsElapsed++;
            testTimer.textContent = formatTime(secondsElapsed);
        }

        // Sauvegarder et Quitter le Quiz
        saveAndQuitQuizBtn.addEventListener('click', async () => {
            if (!currentAITestBeingAnswered) {
                showAlert("Erreur: Aucun quiz actif à sauvegarder.", "Erreur", 'error');
                return;
            }

            const confirmed = await showConfirm('Voulez-vous sauvegarder votre progression et quitter le quiz ? Vous pourrez le reprendre plus tard.', 'Sauvegarder et Quitter');
            if (!confirmed) {
                return;
            }

            clearInterval(timerInterval);
            currentAITestBeingAnswered.duration = secondsElapsed; 
            currentAITestBeingAnswered.status = 'in_progress'; 
            currentAITestBeingAnswered.currentQuestionIndex = currentQuestionIndex; 
            saveDocuments();
            doTestModal.classList.add('hidden');
            currentAITestBeingAnswered = null; 
            currentDocumentForTest = null; 
            renderAITests(); 
            showAlert('Quiz sauvegardé ! Vous pourrez le reprendre depuis la liste "Mes Tests AI".', 'Sauvegarde Réussie', 'success');
        });


        // Terminer le quiz et soumettre les réponses à l'IA pour évaluation
        submitQuizBtn.addEventListener('click', async () => {
            // Vérifier si la clé API est présente
            if (!apiKey) {
                showAlert("Clé API Gemini non configurée. Impossible d'évaluer le test AI.", "Clé API manquante", "error");
                return;
            }

            if (!currentAITestBeingAnswered || !currentDocumentForTest) {
                showAlert("Erreur: Aucun quiz ou document actif pour l'évaluation AI.", "Erreur", 'error');
                return;
            }

            const confirmed = await showConfirm('Voulez-vous terminer le quiz et soumettre vos réponses pour évaluation ?', 'Confirmer la fin du Quiz');
            if (!confirmed) {
                return;
            }

            clearInterval(timerInterval);
            currentAITestBeingAnswered.endTime = new Date().toISOString();
            currentAITestBeingAnswered.duration = secondsElapsed;
            currentAITestBeingAnswered.currentQuestionIndex = currentQuestionIndex; 

            startQuizTimerBtn.classList.add('hidden'); 
            nextQuestionBtn.classList.add('hidden'); 
            prevQuestionBtn.classList.add('hidden'); 
            submitQuizBtn.classList.add('hidden'); 
            saveAndQuitQuizBtn.classList.add('hidden'); 

            quizQuestionOptions.querySelectorAll('input').forEach(input => input.disabled = true); 
            quizWrittenAnswerInput.disabled = true;

            quizEvaluationArea.classList.remove('hidden');
            quizAIEvaluation.textContent = '';
            quizCorrectionContent.textContent = '';
            quizResultsSummary.textContent = '';
            quizGenerationLoading.classList.add('hidden'); 
            quizAIEvaluation.classList.add('hidden'); 
            quizCorrectionContent.classList.add('hidden'); 
            
            const evaluationSpinner = document.createElement('div');
            evaluationSpinner.id = 'evaluationSpinner';
            evaluationSpinner.className = 'flex justify-center items-center py-4';
            evaluationSpinner.innerHTML = `<div class="loading-spinner"></div><p class="ml-4 text-gray-600">L'IA évalue vos réponses et génère le corrigé...</p>`;
            quizEvaluationArea.insertBefore(evaluationSpinner, quizAIEvaluation);

            try {
                const docOriginalContent = currentDocumentForTest.content;
                const quizQuestions = currentAITestBeingAnswered.structuredContent.questions;
                const userAnswers = currentAITestBeingAnswered.userAnswers;

                let questionAnswerSummary = "";
                quizQuestions.forEach((q, index) => {
                    questionAnswerSummary += `Question ${index + 1} (${q.type === 'qcm' ? 'QCM' : 'Écrit'}): ${q.text}\n`;
                    if (q.type === 'qcm') {
                        questionAnswerSummary += `Votre réponse: ${q.options.find(opt => opt.id === userAnswers[index])?.text || "Non répondu"}\n`;
                        questionAnswerSummary += `Bonne réponse: ${q.options.find(opt => opt.id === q.correctAnswerId)?.text}\n\n`;
                    } else if (q.type === 'written') {
                        questionAnswerSummary += `Votre réponse: ${userAnswers[index] || "Non répondu"}\n`;
                        questionAnswerSummary += `Réponse attendue: ${q.correctAnswerText || "Non spécifiée"}\n\n`;
                    }
                });

                let prompt = `En tant qu'évaluateur expert et pédagogue, vous devez évaluer les réponses d'un apprenant à un quiz interactif.
Le quiz a été généré à partir du contenu original suivant :
---
Contenu original du document :
${docOriginalContent}
---

Voici les questions du quiz et les réponses de l'apprenant, ainsi que les bonnes réponses :
---
${questionAnswerSummary}
---

Veuillez effectuer les tâches suivantes:
1.  **Calculer le score brut de l'apprenant** sur ${quizQuestions.length} questions (par exemple, 3/${quizQuestions.length}). Pour les questions écrites, évaluez la pertinence de la réponse par rapport à la réponse attendue et au contenu original.
2.  **Attribuer une note générale de 1 à 5** à la compréhension globale de l'apprenant, en considérant la pertinence et l'exhaustivité de ses réponses par rapport au contenu original et aux questions posées.
    * 1 = Compréhension très faible, erreurs majeures.
    * 2 = Compréhension limitée, beaucoup de lacunes.
    * 3 = Compréhension acceptable, quelques imprécisions.
    * 4 = Bonne compréhension, détails mineurs à améliorer.
    * 5 = Excellente compréhension, précis et complet.
3.  **Fournir une évaluation détaillée et constructive** expliquant pourquoi cette note a été attribuée. Mettez en évidence les points forts et les axes d'amélioration.
4.  **Générer un corrigé détaillé** question par question, expliquant la bonne réponse et pourquoi elle est correcte, en se référant au contenu original si pertinent. Pour les questions écrites, comparez la réponse de l'apprenant à la réponse attendue.

Votre réponse doit être structurée comme follows en utilisant des sections claires et du Markdown pour une meilleure lisibilité:
---
**Score Final: [Score Brute]/${quizQuestions.length}**
**Note de Compréhension (1-5): [Note]/5**

**Évaluation de l'IA:**
[Votre évaluation détaillée ici, en utilisant des listes à puces ou numérotées si pertinent]

**Corrigé Détaillé:**
[Corrigé question par question, en utilisant des listes à puces ou numérotées si pertinent]
---`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Erreur API lors de l\'évaluation AI:', response.status, response.statusText, errorData);
                    quizResultsSummary.textContent = `Erreur lors de l'évaluation AI (Code: ${response.status}). Détails: ${errorData.error?.message || 'Inconnu'}`;
                    showAlert(`Erreur lors de l'évaluation du quiz: ${response.status}`, 'Erreur AI', 'error');
                } else {
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        
                        const scoreMatch = aiResponseText.match(/Score Final:\s*(\d+)\/(\d+)/); 
                        const noteMatch = aiResponseText.match(/Note de Compréhension \(1-5\):\s*(\d)\/5/);
                        const evaluationMatch = aiResponseText.match(/Évaluation de l'IA:\s*([\s\S]*?)(?=Corrigé Détaillé:|$)/);
                        const correctionMatch = aiResponseText.match(/Corrigé Détaillé:\s*([\s\S]*)/);

                        let scoreFinal = scoreMatch ? `${scoreMatch[1]}/${scoreMatch[2]}` : 'N/A';
                        let noteComprehension = noteMatch ? parseInt(noteMatch[1]) : 'N/A';
                        let evaluationContent = evaluationMatch ? evaluationMatch[1].trim() : 'Non disponible.';
                        let correctionContent = correctionMatch ? correctionMatch[1].trim() : 'Non disponible.';

                        quizResultsSummary.innerHTML = marked.parse(`**Score Final:** ${scoreFinal} | **Note de Compréhension:** ${noteComprehension}/5`);
                        quizAIEvaluation.innerHTML = marked.parse(evaluationContent);
                        quizCorrectionContent.innerHTML = marked.parse(correctionContent);

                        currentAITestBeingAnswered.aiEvaluation = aiResponseText; 
                        currentAITestBeingAnswered.aiScore = noteComprehension; 
                        currentAITestBeingAnswered.status = 'completed'; 
                        saveDocuments();

                        quizAIEvaluation.classList.remove('hidden');
                        quizCorrectionContent.classList.remove('hidden');
                        reEvaluateUnderstandingBtn.classList.remove('hidden'); 
                        showAlert('Vos réponses ont été évaluées par l\'IA !', 'Quiz Terminé', 'success');
                    } else {
                        console.error('Structure de réponse inattendue de l\'API Gemini pour l\'évaluation:', result);
                        quizResultsSummary.textContent = "Désolé, l'IA n'a pas pu évaluer vos réponses. La réponse de l'IA n'était pas au format attendu. Veuillez réessayer.";
                        showAlert('La réponse de l\'IA était inattendue.', 'Erreur AI', 'error');
                    }
                }
            } catch (error) {
                console.error('Erreur lors de l\'appel de l\'API Gemini pour l\'évaluation:', error);
                quizResultsSummary.textContent = "Une erreur est survenue lors de l'évaluation par l'IA. Veuillez vérifier votre connexion internet ou réessayer plus tard.";
                showAlert('Erreur de connexion lors de l\'évaluation par l\'IA.', 'Erreur Réseau', 'error');
            } finally {
                const spinnerToRemove = document.getElementById('evaluationSpinner');
                if (spinnerToRemove) spinnerToRemove.remove();
                quizAIEvaluation.classList.remove('hidden');
                quizCorrectionContent.classList.remove('hidden');
                
                renderAITests(); 
            }
        });


        // Gérer le passage de la modale de quiz à la modale de révision
        reEvaluateUnderstandingBtn.addEventListener('click', () => {
            doTestModal.classList.add('hidden'); 

            if (currentAITestBeingAnswered) {
                const doc = documents.find(d => d.aiTests && d.aiTests.some(test => test.id === currentAITestBeingAnswered.id));
                currentReviewingDocumentId = doc ? doc.id : null;

                if (doc) {
                    modalDocumentName.textContent = doc.name;
                    // Render Markdown content (if any) or plain text
                    const content = doc.content;
                    modalDocumentContent.innerHTML = marked.parse(content);

                    reviewModal.classList.remove('hidden');
                    scoreButtons.forEach(btn => btn.classList.remove('selected'));
                    submitReviewBtn.disabled = true;

                    if (currentAITestBeingAnswered.aiScore !== undefined && typeof currentAITestBeingAnswered.aiScore === 'number' && currentAITestBeingAnswered.aiScore >= 1 && currentAITestBeingAnswered.aiScore <= 5) {
                        const scoreBtn = document.querySelector(`.score-button[data-score="${currentAITestBeingAnswered.aiScore}"]`);
                        if (scoreBtn) {
                            scoreBtn.click(); 
                        }
                    } else {
                        selectedScore = null;
                        submitReviewBtn.disabled = true; 
                    }
                }
            }
        });

        // Annuler/Fermer la modale de test AI / Quiz
        closeQuizResultsBtn.addEventListener('click', () => {
            doTestModal.classList.add('hidden');
            clearInterval(timerInterval);
            currentAITestBeingAnswered = null; 
            currentDocumentForTest = null; 
            quizGenerationLoading.classList.add('hidden');
            quizDisplayArea.classList.add('hidden');
            quizEvaluationArea.classList.add('hidden');
            startQuizTimerBtn.classList.remove('hidden'); 
            nextQuestionBtn.classList.add('hidden');
            prevQuestionBtn.classList.add('hidden');
            submitQuizBtn.classList.add('hidden');
            saveAndQuitQuizBtn.classList.add('hidden'); 
            renderAITests(); 
        });

        // Gérer le clic sur le bouton "Supprimer"
        async function handleDeleteButtonClick(event) {
            const docId = event.target.dataset.id;
            const docToDelete = documents.find(d => d.id === docId);

            if (docToDelete) {
                const confirmed = await showConfirm(`Êtes-vous sûr de vouloir supprimer le document "${docToDelete.name}" ? Cette action est irréversible.`, 'Confirmation de suppression');
                if (confirmed) {
                    documents = documents.filter(doc => doc.id !== docId);
                    saveDocuments(); 
                    renderDocuments();
                    renderAITests(); 
                    showAlert(`Le document "${docToDelete.name}" a été supprimé.`, 'Suppression réussie', 'success');
                }
            }
        }

        // Gérer le clic sur le bouton "Supprimer" d'un test AI
        async function handleDeleteAITestButtonClick(event) {
            const docId = event.target.dataset.docId;
            const testId = event.target.dataset.testId;

            const doc = documents.find(d => d.id === docId);
            if (doc && doc.aiTests) {
                const testToDelete = doc.aiTests.find(test => test.id === testId);
                if (testToDelete) {
                    const confirmed = await showConfirm(`Êtes-vous sûr de vouloir supprimer ce test AI pour "${doc.name}" ?`, 'Confirmation de suppression du test AI');
                    if (confirmed) {
                        doc.aiTests = doc.aiTests.filter(test => test.id !== testId);
                        saveDocuments(); 
                        renderAITests();
                        showAlert('Le test AI a été supprimé.', 'Suppression réussie', 'success');
                    }
                }
            }
        }

        // Gérer la sélection du score dans la modale de révision
        scoreButtons.forEach(button => {
            button.addEventListener('click', () => {
                scoreButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedScore = parseInt(button.dataset.score);
                submitReviewBtn.disabled = false;
            });
        });

        submitReviewBtn.addEventListener('click', () => {
            if (currentReviewingDocumentId && selectedScore !== null) {
                const docIndex = documents.findIndex(d => d.id === currentReviewingDocumentId);
                if (docIndex !== -1) {
                    calculateNextReview(documents[docIndex], selectedScore);
                    renderDocuments();
                    reviewModal.classList.add('hidden');
                    currentReviewingDocumentId = null;
                    selectedScore = null;
                    showAlert('Document révisé avec succès !', 'Révision Complète', 'success');
                }
            }
        });


        // Gérer le clic sur le bouton "Voir le corrigé" (utilisé si le test est de type texte simple)
        closeCorrectionBtn.addEventListener('click', () => {
            correctionModal.classList.add('hidden');
        });

        // Gestion des catégories et sous-catégories
        manageCategoriesBtn.addEventListener('click', () => {
            categoryManagementModal.classList.remove('hidden');
            renderCategoriesList();
        });

        closeCategoryManagementBtn.addEventListener('click', () => {
            categoryManagementModal.classList.add('hidden');
            populateCategorySelectors();
            populateFilterCategorySelectors();
        });

        addCategoryBtn.addEventListener('click', () => {
            const newCategoryName = newCategoryNameInput.value.trim();
            if (newCategoryName) {
                if (categories.some(cat => cat.name.toLowerCase() === newCategoryName.toLowerCase())) {
                    showAlert('Cette catégorie existe déjà !', 'Doublon', 'warning');
                    return;
                }
                categories.push({ id: crypto.randomUUID(), name: newCategoryName, subcategories: [] });
                saveDocuments();
                newCategoryNameInput.value = '';
                renderCategoriesList();
                showAlert('Catégorie ajoutée avec succès !', 'Succès', 'success');
            } else {
                showAlert('Veuillez entrer un nom pour la catégorie.', 'Champ vide', 'error');
            }
        });

        function renderCategoriesList() {
            categoriesList.innerHTML = '';
            if (categories.length === 0) {
                categoriesList.innerHTML = '<li class="text-gray-600 italic">Aucune catégorie pour l\'instant.</li>';
                return;
            }

            categories.forEach(cat => {
                const categoryItem = document.createElement('li');
                categoryItem.className = 'bg-gray-100 p-3 rounded-lg shadow-sm';
                categoryItem.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">${cat.name}</span>
                        <div class="flex gap-2">
                            <button data-category-id="${cat.id}" class="btn btn-secondary add-subcategory-btn">➕ Sous-catégorie</button>
                            <button data-category-id="${cat.id}" class="btn btn-danger delete-category-btn">🗑️ Supprimer</button>
                        </div>
                    </div>
                    <ul class="ml-4 mt-2 space-y-1" id="subcategories-list-${cat.id}">
                        ${cat.subcategories.length > 0 ? 
                            cat.subcategories.map(sub => `
                                <li class="flex justify-between items-center bg-gray-200 p-2 rounded-md">
                                    <span class="text-sm text-gray-700">${sub.name}</span>
                                    <button data-category-id="${cat.id}" data-subcategory-id="${sub.id}" class="btn btn-danger text-xs px-2 py-1 delete-subcategory-btn">🗑️</button>
                                </li>
                            `).join('')
                            : '<li class="text-gray-500 italic text-sm">Aucune sous-catégorie.</li>'
                        }
                    </ul>
                `;
                categoriesList.appendChild(categoryItem);
            });
            attachCategoryListEventListeners();
        }

        function attachCategoryListEventListeners() {
            document.querySelectorAll('.add-subcategory-btn').forEach(button => {
                button.removeEventListener('click', handleAddSubcategoryClick); 
                button.addEventListener('click', handleAddSubcategoryClick);
            });
            document.querySelectorAll('.delete-category-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteCategoryClick); 
                button.addEventListener('click', handleDeleteCategoryClick);
            });
            document.querySelectorAll('.delete-subcategory-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteSubcategoryClick); 
                button.addEventListener('click', handleDeleteSubcategoryClick);
            });
        }

        async function handleAddSubcategoryClick(event) {
            const categoryId = event.target.dataset.categoryId;
            const category = categories.find(cat => cat.id === categoryId);
            if (category) {
                // Remplacé prompt() par une alerte personnalisée avec input si nécessaire, ou simplification
                const subcategoryName = prompt(`Ajouter une sous-catégorie pour "${category.name}" :`);
                if (subcategoryName && subcategoryName.trim()) {
                    if (category.subcategories.some(sub => sub.name.toLowerCase() === subcategoryName.trim().toLowerCase())) {
                        showAlert('Cette sous-catégorie existe déjà !', 'Doublon', 'warning');
                        return;
                    }
                    category.subcategories.push({ id: crypto.randomUUID(), name: subcategoryName.trim() });
                    saveDocuments();
                    renderCategoriesList();
                    showAlert('Sous-catégorie ajoutée avec succès !', 'Succès', 'success');
                } else if (subcategoryName !== null) { 
                    showAlert('Veuillez entrer un nom pour la sous-catégorie.', 'Champ vide', 'error');
                }
            }
        }

        async function handleDeleteCategoryClick(event) {
            const categoryId = event.target.dataset.categoryId;
            const categoryToDelete = categories.find(cat => cat.id === categoryId);
            if (categoryToDelete) {
                const confirmed = await showConfirm(`Êtes-vous sûr de vouloir supprimer la catégorie "${categoryToDelete.name}" et toutes ses sous-catégories ? Les documents associés seront "Non classés".`, 'Confirmation de suppression');
                if (confirmed) {
                    categories = categories.filter(cat => cat.id !== categoryId);
                    documents.forEach(doc => {
                        if (doc.category === categoryToDelete.name) {
                            doc.category = 'Non classé';
                            doc.subcategory = 'Non classé'; 
                        }
                    });
                    saveDocuments();
                    renderCategoriesList();
                    renderDocuments(); 
                    showAlert('Catégorie supprimée.', 'Succès', 'success');
                }
            }
        }

        async function handleDeleteSubcategoryClick(event) {
            const categoryId = event.target.dataset.categoryId;
            const subcategoryId = event.target.dataset.subcategoryId;
            const category = categories.find(cat => cat.id === categoryId);

            if (category) {
                const subcategoryToDelete = category.subcategories.find(sub => sub.id === subcategoryId);
                if (subcategoryToDelete) {
                    const confirmed = await showConfirm(`Êtes-vous sûr de vouloir supprimer la sous-catégorie "${subcategoryToDelete.name}" ? Les documents associés seront "Non classés".`, 'Supprimer la sous-catégorie');
                    if (confirmed) {
                        category.subcategories = category.subcategories.filter(sub => sub.id !== subcategoryId);
                        documents.forEach(doc => {
                            if (doc.subcategory === subcategoryToDelete.name && doc.category === category.name) {
                                doc.subcategory = 'Non classé';
                            }
                        });
                        saveDocuments();
                        renderCategoriesList();
                        renderDocuments(); 
                        showAlert('Sous-catégorie supprimée.', 'Succès', 'success');
                    }
                }
            }
        }

        // Fonction pour afficher les messages dans le chat AI
        function displayChatMessage(role, text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `p-2 rounded-lg max-w-[80%] my-1 text-sm `; 
            
            if (role === 'user') {
                messageDiv.classList.add('chat-message-user'); 
            } else {
                // Keep 'chat-message-ai' class for styling, but API role is 'model'
                messageDiv.classList.add('chat-message-ai'); 
            }
            messageDiv.textContent = text; // Use textContent for security and simple display
            aiChatDisplay.appendChild(messageDiv);
            aiChatDisplay.scrollTop = aiChatDisplay.scrollHeight; 
        }

        // Événement d'envoi de message au chat AI
        sendAIChatBtn.addEventListener('click', async () => {
            // Vérifier si la clé API est présente
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre clé API Gemini. Le chat AI ne fonctionnera pas sans elle.", "Clé API manquante", "warning");
                return;
            }

            const userMessage = aiChatInput.value.trim();
            if (!userMessage) {
                showAlert("Veuillez taper votre question.", "Question vide", 'warning');
                return;
            }

            const doc = documents.find(d => d.id === currentReviewingDocumentId);
            if (!doc) {
                showAlert("Erreur: Document non trouvé pour le chat AI.", "Erreur Chat", 'error');
                return;
            }

            displayChatMessage('user', userMessage);
            doc.aiChatHistory.push({ role: 'user', text: userMessage });
            saveDocuments();
            aiChatInput.value = ''; 
            aiChatLoading.classList.remove('hidden'); 
            sendAIChatBtn.disabled = true; 

            try {
                const documentContent = doc.content;
                // Construct the prompt using the entire chat history for context
                let currentChatHistory = doc.aiChatHistory.map(msg => ({
                    role: msg.role === 'ai' ? 'model' : msg.role, // FIX: Map 'ai' role to 'model' for API
                    parts: [{ text: msg.text }]
                }));

                // Ensure the initial system prompt is sent with the first user message only
                // This structure is fine as is, since the 'initialPrompt' becomes part of the
                // first user message's text, and subsequent turns just alternate user/model roles.
                // The main fix is ensuring all 'ai' roles from `doc.aiChatHistory` are converted to 'model'
                // when sending to the Gemini API.

                const payload = { contents: currentChatHistory }; 

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Erreur API lors du chat AI:', response.status, response.statusText, errorData);
                    displayChatMessage('ai', `Désolé, une erreur est survenue lors de la communication avec l'IA. (Code: ${response.status}). Veuillez réessayer. Détails: ${errorData.error?.message || 'Inconnu'}`);
                } else {
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        displayChatMessage('ai', aiResponseText);
                        doc.aiChatHistory.push({ role: 'model', text: aiResponseText }); // FIX: Push with 'model' role
                        saveDocuments();
                    } else {
                        console.error('Structure de réponse inattendue de l\'API Gemini pour le chat:', result);
                        displayChatMessage('ai', "Désolé, l'IA n'a pas pu répondre. La structure de la réponse était inattendue.");
                    }
                }
            } catch (error) {
                console.error('Erreur lors de l\'appel de l\'API Gemini pour le chat:', error);
                displayChatMessage('ai', "Une erreur est survenue lors du chat avec l'IA. Vérifiez votre connexion internet.");
            } finally {
                aiChatLoading.classList.add('hidden'); 
                sendAIChatBtn.disabled = false; 
            }
        });

        // Add event listener for Enter key in chat input
        aiChatInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); 
                sendAIChatBtn.click(); 
            }
        });

        // Fonction d'exportation des données
        exportDataBtn.addEventListener('click', () => {
            try {
                const dataToExport = {
                    documents: documents,
                    categories: categories
                };
                const dataStr = JSON.stringify(dataToExport, null, 2); 
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rvsion_data_export_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showAlert('Données exportées avec succès !', 'Exportation Réussie', 'success');
            } catch (e) {
                console.error('Erreur lors de l\'exportation des données:', e);
                showAlert('Erreur lors de l\'exportation des données.', 'Erreur d\'Exportation', 'error');
            }
        });

        // Fonction d'importation des données
        importDataBtn.addEventListener('click', () => {
            importFileInput.click(); 
        });

        importFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    const confirmed = await showConfirm(
                        'L\'importation des données va remplacer toutes vos données actuelles. Voulez-vous continuer ?',
                        'Confirmer l\'Importation'
                    );

                    if (confirmed) {
                        if (importedData.documents && Array.isArray(importedData.documents) &&
                            importedData.categories && Array.isArray(importedData.categories)) {
                            
                            const isValidDocuments = importedData.documents.every(doc => 
                                doc.id && doc.name && doc.content && doc.lastReviewed && doc.nextReview
                            );
                            const isValidCategories = importedData.categories.every(cat => 
                                cat.id && cat.name && Array.isArray(cat.subcategories)
                            );

                            if (isValidDocuments && isValidCategories) {
                                documents = importedData.documents.map(doc => ({
                                    ...doc,
                                    lastReviewed: new Date(doc.lastReviewed),
                                    nextReview: new Date(doc.nextReview),
                                    aiTests: doc.aiTests ? doc.aiTests.map(test => ({
                                        ...test,
                                        generatedAt: new Date(test.generatedAt),
                                        startTime: test.startTime ? new Date(test.startTime) : null,
                                        endTime: test.endTime ? new Date(test.endTime) : null,
                                        config: test.config || { difficulty: 'Moyen', questionType: 'qcm', numQuestions: 5 }, 
                                        currentQuestionIndex: test.currentQuestionIndex !== undefined ? test.currentQuestionIndex : 0 
                                    })) : [],
                                    aiChatHistory: doc.aiChatHistory || [],
                                    flashcards: doc.flashcards || []
                                }));
                                categories = importedData.categories;
                                saveDocuments();
                                renderDocuments();
                                renderAITests();
                                showAlert('Données importées avec succès !', 'Importation Réussie', 'success');
                            } else {
                                showAlert('Le fichier JSON n\'a pas le format attendu pour les documents ou les catégories. Importation annulée.', 'Erreur de Format', 'error');
                            }
                        } else {
                            showAlert('Le fichier JSON ne contient pas les clés "documents" et "categories" ou elles sont mal formattées. Importation annulée.', 'Erreur de Format', 'error');
                        }
                    } else {
                        showAlert('Importation annulée par l\'utilisateur.', 'Annulé', 'info');
                    }

                } catch (e) {
                    console.error('Erreur lors de l\'importation ou du parsing du fichier JSON:', e);
                    showAlert('Erreur lors de l\'importation du fichier. Assurez-vous que c\'est un fichier JSON valide.', 'Erreur d\'Importation', 'error');
                }
            };
            reader.readAsText(file);
        });


        // --- Global Event Listener Initialization ---
        function initGlobalEventListeners() {
            closeAlertBtn.addEventListener('click', () => {
                customAlertModal.classList.add('hidden');
            });
            cancelReviewBtn.addEventListener('click', () => {
                reviewModal.classList.add('hidden');
                currentReviewingDocumentId = null;
                selectedScore = null;
            });
            cancelTestConfigBtn.addEventListener('click', () => {
                testConfigModal.classList.add('hidden');
                currentDocumentForTest = null;
            });
            // La logique de ces boutons est définie plus haut et ne doit pas être ré-assignée ici
            // prepareInteractiveTestBtn.addEventListener('click', async () => { /* Logic defined above */ });
            // nextQuestionBtn.addEventListener('click', () => { /* Logic defined above */ });
            // prevQuestionBtn.addEventListener('click', () => { /* Logic defined above */ });
            // startQuizTimerBtn.addEventListener('click', () => { /* Logic defined above */ });
            // submitQuizBtn.addEventListener('click', async () => { /* Logic defined above */ });
            // reEvaluateUnderstandingBtn.addEventListener('click', () => { /* Logic defined above */ });
            // closeQuizResultsBtn.addEventListener('click', () => { /* Logic defined above */ });
            // saveAndQuitQuizBtn.addEventListener('click', async () => { /* Logic defined above */ }); 
            
            searchDocumentInput.addEventListener('input', renderDocuments);
            filterStatusSelect.addEventListener('change', renderDocuments);
            documentCategorySelect.addEventListener('change', () => {
                const selectedCategoryId = documentCategorySelect.value;
                documentSubcategorySelect.innerHTML = '<option value="">Sélectionner une sous-catégorie</option>';
                documentSubcategorySelect.disabled = true;

                if (selectedCategoryId) {
                    const selectedCategory = categories.find(cat => cat.id === selectedCategoryId);
                    if (selectedCategory && selectedCategory.subcategories.length > 0) {
                        selectedCategory.subcategories.forEach(sub => {
                            const option = document.createElement('option');
                            option.value = sub.id;
                            option.textContent = sub.name;
                            documentSubcategorySelect.appendChild(option);
                        });
                        documentSubcategorySelect.disabled = false;
                    }
                }
            });
            filterCategorySelect.addEventListener('change', () => {
                const selectedCategoryId = filterCategorySelect.value;
                filterSubcategorySelect.innerHTML = '<option value="all">Toutes sous-catégories</option>';
                filterSubcategorySelect.disabled = true;

                if (selectedCategoryId && selectedCategoryId !== 'all') {
                    const selectedCategory = categories.find(cat => cat.id === selectedCategoryId);
                    if (selectedCategory && selectedCategory.subcategories.length > 0) {
                        selectedCategory.subcategories.forEach(sub => {
                            const option = document.createElement('option');
                            option.value = sub.id;
                            option.textContent = sub.name;
                            filterSubcategorySelect.appendChild(option);
                        });
                        filterSubcategorySelect.disabled = false;
                    }
                }
                renderDocuments();
            });
            filterSubcategorySelect.addEventListener('change', renderDocuments);
            // exportDataBtn.addEventListener('click', () => { /* Logic defined above */ });
            // importDataBtn.addEventListener('click', () => { /* Logic defined above */ });
            // importFileInput.addEventListener('change', (event) => { /* Logic defined above */ });
            // closeCorrectionBtn.addEventListener('click', () => { /* Logic defined above */ });
            // manageCategoriesBtn.addEventListener('click', () => { /* Logic defined above */ });
            // closeCategoryManagementBtn.addEventListener('click', () => { /* Logic defined above */ });
            // addCategoryBtn.addEventListener('click', () => { /* Logic defined above */ });
            // scoreButtons.forEach(button => { /* Logic defined above */ });

            // Flashcard specific event listeners
            flipFlashcardBtn.addEventListener('click', () => {
                flashcardCard.classList.toggle('flipped'); // Toggle the flipped class
                isFlashcardFlipped = !isFlashcardFlipped;
            });
            prevFlashcardBtn.addEventListener('click', () => {
                if (currentFlashcardIndex > 0) {
                    currentFlashcardIndex--;
                    displayFlashcard();
                }
            });
            nextFlashcardBtn.addEventListener('click', () => {
                if (currentFlashcardIndex < currentFlashcards.length - 1) {
                    currentFlashcardIndex++;
                    displayFlashcard();
                }
            });
            closeFlashcardModalBtn.addEventListener('click', () => {
                flashcardModal.classList.add('hidden');
                currentFlashcards = [];
                currentFlashcardIndex = 0;
                isFlashcardFlipped = false;
                numFlashcardsToGenerateInput.value = ''; // Reset input
                generateFlashcardsWithAIButton.classList.add('hidden'); // Hide until doc selected again
            });

            // NEW Flashcard Management Modal Buttons
            openManageFlashcardsModalButton.addEventListener('click', () => {
                if (!currentManagingDocumentId) {
                    showAlert("Veuillez sélectionner un document pour gérer les flashcards.", "Document manquant", "warning");
                    return;
                }
                flashcardModal.classList.add('hidden'); // Hide main flashcard modal
                openManageFlashcardsModal(currentManagingDocumentId);
            });
            closeManageFlashcardsModalBtn.addEventListener('click', () => {
                manageFlashcardsModal.classList.add('hidden');
                // Reopen the main flashcard modal, preserving state if desired
                if (currentManagingDocumentId) {
                    handleFlashcardsButtonClick({ target: { dataset: { id: currentManagingDocumentId } } });
                }
            });
            generateFlashcardsWithAIButton.addEventListener('click', () => {
                const num = parseInt(numFlashcardsToGenerateInput.value);
                generateFlashcardsAI(currentManagingDocumentId, num);
            });
            addFlashcardManuallyBtn.addEventListener('click', () => {
                const question = newFlashcardQuestionInput.value.trim();
                const answer = newFlashcardAnswerInput.value.trim();

                if (question && answer) {
                    const doc = documents.find(d => d.id === currentManagingDocumentId);
                    if (doc) {
                        if (!doc.flashcards) {
                            doc.flashcards = [];
                        }
                        doc.flashcards.push({ id: crypto.randomUUID(), question, answer });
                        saveDocuments();
                        renderFlashcardsManagementList();
                        newFlashcardQuestionInput.value = '';
                        newFlashcardAnswerInput.value = '';
                        showAlert('Flashcard ajoutée manuellement !', 'Succès', 'success');
                        // If currently viewing flashcards, update display
                        if (flashcardModal.classList.contains('hidden') === false) {
                            currentFlashcards = doc.flashcards; // Update the current flashcards array
                            currentFlashcardIndex = currentFlashcards.length - 1; // Go to new card
                            displayFlashcard();
                        }
                    }
                } else {
                    showAlert('Veuillez entrer une question et une réponse pour la flashcard.', 'Champs vides', 'error');
                }
            });


            // --- NEW: API Key Save Listener ---
            saveApiKeyBtn.addEventListener('click', () => {
                const newKey = apiKeyInput.value.trim();
                if (newKey) {
                    localStorage.setItem('geminiApiKey', newKey);
                    apiKey = newKey; // Update the global API key
                    showAlert('Clé API Gemini sauvegardée avec succès !', 'Succès', 'success');
                } else {
                    localStorage.removeItem('geminiApiKey'); // Clear the key if input is empty
                    apiKey = ""; // Clear global API key
                    showAlert('Clé API Gemini effacée du stockage local.', 'Information', 'info');
                }
            });
            // --- END NEW: API Key Save Listener ---
        }
        // --- END Global Event Listener Initialization ---

        // Handler for Flashcards button click
        async function handleFlashcardsButtonClick(event) {
            // Vérifier si la clé API est présente
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre clé API Gemini. La génération de flashcards ne fonctionnera pas sans elle.", "Clé API manquante", "warning");
                return;
            }

            const docId = event.target.dataset.id;
            const doc = documents.find(d => d.id === docId);
            if (!doc) return;

            flashcardModal.classList.remove('hidden');
            flashcardLoading.classList.remove('hidden');
            flipFlashcardBtn.disabled = true;
            prevFlashcardBtn.disabled = true;
            nextFlashcardBtn.disabled = true;
            flashcardQuestionDisplay.innerHTML = ''; // Use innerHTML for Markdown
            flashcardAnswerDisplay.innerHTML = ''; // Use innerHTML for Markdown
            flashcardCard.classList.remove('flipped'); // Ensure not flipped initially
            isFlashcardFlipped = false;
            currentManagingDocumentId = docId; // Set the document being managed for flashcards

            if (doc.flashcards && doc.flashcards.length > 0) {
                currentFlashcards = doc.flashcards;
                currentFlashcardIndex = 0;
                flashcardLoading.classList.add('hidden');
                displayFlashcard();
            } else {
                // If no flashcards, suggest generation
                flashcardLoading.classList.add('hidden');
                showAlert("Aucune flashcard existante. Générez-en via l'IA ou ajoutez-en manuellement.", "Flashcards", "info");
                numFlashcardsToGenerateInput.value = '10'; // Default value
                displayFlashcard(); // Display "no flashcards" message
            }
        }

        async function generateFlashcardsAI(docId, numFlashcards) {
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre clé API Gemini. La génération de flashcards ne fonctionnera pas sans elle.", "Clé API manquante", "warning");
                return;
            }
            const doc = documents.find(d => d.id === docId);
            if (!doc) return;

            flashcardLoading.classList.remove('hidden');
            flipFlashcardBtn.disabled = true;
            prevFlashcardBtn.disabled = true;
            nextFlashcardBtn.disabled = true;

            try {
                let prompt = `Génère ${numFlashcards && !isNaN(numFlashcards) ? numFlashcards : '10'} flashcards (question et réponse) en format JSON à partir du texte suivant.
                Le JSON doit avoir une propriété "flashcards" qui est un tableau d'objets. Chaque objet flashcard doit avoir les propriétés "question" (string) et "answer" (string).
                Utilise le formatage Markdown (texte en gras avec **, listes à puces avec -) pour le contenu des questions et réponses si cela améliore la clarté.
                Texte du document:
                ---
                ${doc.content}
                ---
                Fournis uniquement le JSON.`;

                // If numFlashcards is not provided, modify prompt for AI to decide
                if (!numFlashcards || isNaN(numFlashcards)) {
                    prompt = `Génère un nombre suffisant et pertinent de flashcards (question et réponse) en format JSON à partir du texte suivant.
                    Le JSON doit avoir une propriété "flashcards" qui est un tableau d'objets. Chaque objet flashcard doit avoir les propriétés "question" (string) et "answer" (string).
                    Utilise le formatage Markdown (texte en gras avec **, listes à puces avec -) pour le contenu des questions et réponses si cela améliore la clarté.
                    Texte du document:
                    ---
                    ${doc.content}
                    ---
                    Fournis uniquement le JSON.`;
                }


                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "flashcards": {
                                    "type": "ARRAY",
                                    "items": {
                                        "type": "OBJECT",
                                        "properties": {
                                            "question": { "type": "STRING" },
                                            "answer": { "type": "STRING" }
                                        },
                                        "required": ["question", "answer"]
                                    }
                                }
                            },
                            "required": ["flashcards"]
                        }
                    }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Échec de l'IA: ${errorData.error?.message || response.statusText}`);
                }
                const result = await response.json();
                const flashcardData = JSON.parse(result.candidates[0].content.parts[0].text);

                if (flashcardData.flashcards && Array.isArray(flashcardData.flashcards) && flashcardData.flashcards.length > 0) {
                    doc.flashcards = flashcardData.flashcards.map(fc => ({
                        id: crypto.randomUUID(), // Add unique ID for manual editing/deletion
                        question: fc.question,
                        answer: fc.answer
                    }));
                    saveDocuments();
                    currentFlashcards = doc.flashcards;
                    currentFlashcardIndex = 0;
                    displayFlashcard();
                    showAlert('Flashcards générées avec succès !', 'Succès AI', 'success');
                } else {
                    showAlert('L\'IA n\'a pas pu générer les flashcards.', 'Erreur AI', 'error');
                    flashcardModal.classList.add('hidden');
                }
            } catch (error) {
                console.error('Erreur lors de la génération des flashcards:', error);
                showAlert('Erreur lors de la génération des flashcards: ' + error.message, 'Erreur AI', 'error');
                flashcardModal.classList.add('hidden');
            } finally {
                flashcardLoading.classList.add('hidden');
                flipFlashcardBtn.disabled = currentFlashcards.length === 0;
                prevFlashcardBtn.disabled = currentFlashcards.length === 0 || currentFlashcardIndex === 0;
                nextFlashcardBtn.disabled = currentFlashcards.length === 0 || currentFlashcardIndex === currentFlashcards.length - 1;
            }
        }

        // Display current flashcard
        function displayFlashcard() {
            if (currentFlashcards.length === 0) {
                flashcardQuestionDisplay.innerHTML = marked.parse("Aucune flashcard disponible. Générez-en via l'IA ou ajoutez-en manuellement.");
                flashcardAnswerDisplay.innerHTML = "";
                flashcardCard.classList.remove('flipped');
                isFlashcardFlipped = false;
                flipFlashcardBtn.disabled = true;
                prevFlashcardBtn.disabled = true;
                nextFlashcardBtn.disabled = true;
                currentFlashcardIndexDisplay.textContent = 0;
                totalFlashcardsDisplay.textContent = 0;
                return;
            }

            const flashcard = currentFlashcards[currentFlashcardIndex];
            flashcardQuestionDisplay.innerHTML = marked.parse(flashcard.question);
            flashcardAnswerDisplay.innerHTML = marked.parse(flashcard.answer);
            
            // Reset flip state and hide back of card
            flashcardCard.classList.remove('flipped'); 
            isFlashcardFlipped = false;

            currentFlashcardIndexDisplay.textContent = currentFlashcardIndex + 1;
            totalFlashcardsDisplay.textContent = currentFlashcards.length;

            flipFlashcardBtn.disabled = false;
            prevFlashcardBtn.disabled = (currentFlashcardIndex === 0);
            nextFlashcardBtn.disabled = (currentFlashcardIndex === currentFlashcards.length - 1);
        }

        // Flashcard Management functions
        function openManageFlashcardsModal(docId) {
            currentManagingDocumentId = docId;
            const doc = documents.find(d => d.id === docId);
            if (!doc) return;

            manageFlashcardsDocumentName.textContent = doc.name;
            renderFlashcardsManagementList();
            manageFlashcardsModal.classList.remove('hidden');
            newFlashcardQuestionInput.value = '';
            newFlashcardAnswerInput.value = '';
        }

        function renderFlashcardsManagementList() {
            flashcardsManagementList.innerHTML = '';
            const doc = documents.find(d => d.id === currentManagingDocumentId);
            if (!doc || !doc.flashcards || doc.flashcards.length === 0) {
                flashcardsManagementList.innerHTML = '<li class="text-gray-600 italic">Aucune flashcard pour l\'instant.</li>';
                return;
            }

            doc.flashcards.forEach(fc => {
                const li = document.createElement('li');
                li.className = 'bg-gray-100 p-3 rounded-lg shadow-sm';
                li.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800 flex-grow mr-2">Q: ${marked.parse(fc.question).replace(/<p>|<\/p>/g, '')}</span>
                        <div class="flex gap-2">
                            <button data-flashcard-id="${fc.id}" class="btn btn-info text-xs px-2 py-1 edit-flashcard-btn">✏️</button>
                            <button data-flashcard-id="${fc.id}" class="btn btn-danger text-xs px-2 py-1 delete-flashcard-btn">🗑️</button>
                        </div>
                    </div>
                    <div class="flex justify-between items-center text-sm text-gray-600">
                        <span class="flex-grow mr-2">R: ${marked.parse(fc.answer).replace(/<p>|<\/p>/g, '')}</span>
                    </div>
                `;
                flashcardsManagementList.appendChild(li);
            });

            attachFlashcardManagementEventListeners();
        }

        function attachFlashcardManagementEventListeners() {
            document.querySelectorAll('.edit-flashcard-btn').forEach(button => {
                button.removeEventListener('click', handleEditFlashcardClick);
                button.addEventListener('click', handleEditFlashcardClick);
            });
            document.querySelectorAll('.delete-flashcard-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteFlashcardClick);
                button.addEventListener('click', handleDeleteFlashcardClick);
            });
        }

        async function handleEditFlashcardClick(event) {
            const flashcardId = event.target.dataset.flashcardId;
            const doc = documents.find(d => d.id === currentManagingDocumentId);
            if (!doc) return;
            const flashcardToEdit = doc.flashcards.find(fc => fc.id === flashcardId);
            if (flashcardToEdit) {
                const newQuestion = prompt('Modifier la question:', flashcardToEdit.question);
                if (newQuestion === null) return; // User cancelled
                const newAnswer = prompt('Modifier la réponse:', flashcardToEdit.answer);
                if (newAnswer === null) return; // User cancelled

                if (newQuestion.trim() && newAnswer.trim()) {
                    flashcardToEdit.question = newQuestion.trim();
                    flashcardToEdit.answer = newAnswer.trim();
                    saveDocuments();
                    renderFlashcardsManagementList();
                    showAlert('Flashcard modifiée avec succès !', 'Succès', 'success');
                    // If currently viewing flashcards, update display
                    if (flashcardModal.classList.contains('hidden') === false) {
                        displayFlashcard();
                    }
                } else {
                    showAlert('La question et la réponse ne peuvent pas être vides.', 'Champs vides', 'error');
                }
            }
        }

        async function handleDeleteFlashcardClick(event) {
            const flashcardId = event.target.dataset.flashcardId;
            const doc = documents.find(d => d.id === currentManagingDocumentId);
            if (!doc) return;
            const flashcardToDelete = doc.flashcards.find(fc => fc.id === flashcardId);

            if (flashcardToDelete) {
                const confirmed = await showConfirm(`Êtes-vous sûr de vouloir supprimer cette flashcard ?`, 'Confirmer la suppression');
                if (confirmed) {
                    doc.flashcards = doc.flashcards.filter(fc => fc.id !== flashcardId);
                    saveDocuments();
                    renderFlashcardsManagementList();
                    showAlert('Flashcard supprimée.', 'Succès', 'success');
                    // If currently viewing flashcards, refresh display and reset index if necessary
                    if (flashcardModal.classList.contains('hidden') === false) {
                        if (currentFlashcardIndex >= doc.flashcards.length && doc.flashcards.length > 0) {
                            currentFlashcardIndex = doc.flashcards.length - 1;
                        }
                        displayFlashcard();
                    }
                }
            }
        }

        function handleEditDocumentButtonClick(event) {
            const docId = event.target.dataset.id;
            const doc = documents.find(d => d.id === docId);
            if (doc) {
                // Populate the "Add New Document" section
                documentNameInput.value = doc.name;
                documentContentInput.value = doc.content;
                aiDocumentActionSelect.value = 'none'; // Reset AI action for editing

                // Populate category and subcategory
                const categoryObj = categories.find(cat => cat.name === doc.category);
                if (categoryObj) {
                    documentCategorySelect.value = categoryObj.id;
                    // Trigger change to populate subcategories
                    const event = new Event('change');
                    documentCategorySelect.dispatchEvent(event);

                    const subcategoryObj = categoryObj.subcategories.find(sub => sub.name === doc.subcategory);
                    if (subcategoryObj) {
                        documentSubcategorySelect.value = subcategoryObj.id;
                    } else {
                        documentSubcategorySelect.value = ''; // Reset subcategory if not found
                    }
                } else {
                    documentCategorySelect.value = ''; // Reset category if not found
                    documentSubcategorySelect.innerHTML = '<option value="">Sélectionner une sous-catégorie</option>';
                    documentSubcategorySelect.disabled = true;
                }

                // Set editing state
                editingDocumentId = docId;
                addDocumentBtn.textContent = '💾 Enregistrer les modifications';
                showAlert(`Vous modifiez le document "${doc.name}".`, 'Modification', 'info');

                // Scroll to the add/edit section
                documentNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }


        // NEW: Load marked.js for Markdown parsing
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
        script.onload = () => {
            marked.setOptions({
                gfm: true, 
                breaks: true, 
                sanitize: true 
            });
            // Initialiser l'application après le chargement de marked.js
            loadApiKeyFromLocalStorage(); // Charger la clé API en premier
            window.onload = loadDocuments; 
        };
        document.head.appendChild(script);

        // Fallback if marked.js fails to load
        if (!window.marked) {
            console.warn("marked.js failed to load, Markdown rendering will not be available.");
            // Initialiser l'application même si marked.js ne charge pas
            loadApiKeyFromLocalStorage(); // Charger la clé API en premier
            window.onload = loadDocuments; 
        }

    </script>
</body>
</html>
