<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RVsion - R√©p√©tition Espac√©e & Tests AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Styles personnalis√©s pour une meilleure lisibilit√© et esth√©tique */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Arri√®re-plan gris clair */
        }
        .container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        .btn {
            @apply px-4 py-2 rounded-lg font-medium transition-all duration-200 flex items-center justify-center gap-2; /* Ajout gap pour les ic√¥nes */
        }
        .btn-primary {
            @apply bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800;
        }
        .btn-secondary {
            @apply bg-gray-200 text-gray-800 hover:bg-gray-300 active:bg-gray-400;
        }
        .btn-success {
            @apply bg-green-500 text-white hover:bg-green-600 active:bg-green-700;
        }
        .btn-warning {
            @apply bg-yellow-500 text-white hover:bg-yellow-600 active:bg-yellow-700;
        }
        .btn-danger {
            @apply bg-red-500 text-white hover:bg-red-600 active:bg-red-700;
        }
        .btn-info {
            @apply bg-cyan-500 text-white hover:bg-cyan-600 active:bg-cyan-700;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 700px;
            transform: translateY(-20px);
            opacity: 0;
            animation: fadeInScale 0.3s forwards;
            max-height: 90vh;
            overflow-y: auto;
        }
        @keyframes fadeInScale {
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .score-button {
            @apply w-12 h-12 flex items-center justify-center text-lg font-bold rounded-full border-2 border-transparent transition-all duration-200;
        }
        .score-button:hover {
            @apply border-blue-500;
        }
        .score-button.selected {
            @apply bg-blue-500 text-white border-blue-600;
        }
        .document-content-display {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 12px; /* Slightly more rounded */
            padding: 1.5rem; /* Increased padding */
            margin-bottom: 1.5rem;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
            /* NEW STYLES for readability */
            font-family: 'Lato', sans-serif; /* Modern, clean font */
            font-size: 1.05rem; /* Slightly larger text */
            line-height: 1.6; /* Improved line spacing */
            color: #374151; /* Darker grey for better contrast */
        }
        .loading-spinner {
            border: 4px rgba(0, 0, 0, 0.1);
            border-left-color: #2563eb;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Styles pour les messages d'alerte/confirmation */
        .alert-message {
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 500;
        }
        .alert-success {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #34d399;
        }
        .alert-error {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
        .alert-info {
            background-color: #dbeafe;
            color: #1e40af;
            border: 1px solid #60a5fa;
        }
        .alert-warning {
            background-color: #fffbeb;
            color: #b45309;
            border: 1px solid #fcd34d;
        }

        /* Styles sp√©cifiques au quiz interactif */
        .quiz-option {
            @apply flex items-center p-3 rounded-lg border border-gray-300 cursor-pointer transition-colors duration-200;
        }
        .quiz-option:hover {
            @apply bg-gray-100;
        }
        .quiz-option.selected {
            @apply bg-blue-100 border-blue-500;
        }
        .quiz-option input[type="radio"] {
            @apply mr-3;
        }

        /* Chat Message Animations */
        .chat-message-user, .chat-message-ai {
            opacity: 0;
            transform: translateY(20px);
            animation: slideInFadeIn 0.3s ease-out forwards;
        }

        .chat-message-user {
            background-color: #dbeafe; /* Blue-100 for user messages */
            align-self: flex-end; /* Align to right */
        }

        .chat-message-ai {
            background-color: #e5e7eb; /* Gray-200 for AI messages */
            align-self: flex-start; /* Align to left */
        }

        @keyframes slideInFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Flashcard specific styles */
        .flashcard-wrapper {
            perspective: 1000px; /* Needed for 3D flip */
            width: 100%;
            height: 250px; /* Fixed height for the card */
            margin: 0 auto;
            position: relative;
        }

        .flashcard-card {
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Subtle shadow */
        }

        .flashcard-card.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden; /* Hide back of the card during flip */
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            border-radius: 1rem;
            text-align: center;
            font-size: 1.25rem;
            font-weight: 600;
            color: #374151;
        }

        .flashcard-front {
            background: linear-gradient(135deg, #fef2f2, #fee2e2); /* Light red gradient */
            border: 2px solid #fca5a5;
        }

        .flashcard-back {
            background: linear-gradient(135deg, #d1fae5, #a7f3d0); /* Light green gradient */
            border: 2px solid #6ee7b7;
            transform: rotateY(180deg);
            color: #065f46; /* Darker green for text */
            font-style: normal;
        }

        .flashcard-text-content {
            padding: 1rem;
            border-radius: 0.5rem;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }
        
        /* Adaptations mobiles - √Ä ajouter dans votre section <style> */
        @media (max-width: 768px) {
            .container {
                margin: 0.5rem;
                padding: 1rem;
                border-radius: 8px;
            }
            
            /* R√©duction des marges/padding sur mobile */
            .mobile-reduced-padding {
                padding: 0.5rem !important;
            }
            
            .mobile-text-sm {
                font-size: 0.875rem !important;
            }
            
            /* Stack les √©l√©ments flex sur mobile */
            .mobile-stack {
                flex-direction: column !important;
            }
            
            /* Pleine largeur sur mobile */
            .mobile-full-width {
                width: 100% !important;
            }
            
            /* Espacement r√©duit sur mobile */
            .mobile-gap-2 {
                gap: 0.5rem !important;
            }
            
            /* Boutons adapt√©s mobile */
            .mobile-btn-small {
                padding: 0.5rem 0.75rem !important;
                font-size: 0.875rem !important;
            }
            
            /* Modales adapt√©es mobile */
            .modal-content {
                margin: 1rem !important;
                max-height: 95vh !important;
                overflow-y: auto !important;
            }
        }

        @media (max-width: 480px) {
            /* Tr√®s petits √©crans */
            .container {
                margin: 0.25rem;
                padding: 0.75rem;
            }
            
            .mobile-xs-text {
                font-size: 0.75rem !important;
            }
            
            .mobile-xs-btn {
                padding: 0.375rem 0.5rem !important;
                font-size: 0.75rem !important;
            }
        }

        /* Style responsive pour les tableaux */
        @media (max-width: 768px) {
            .table-responsive {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .table-responsive table {
                min-width: 600px;
            }
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4">
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-blue-700 mb-6">RVsion</h1>

        <div class="mb-8 p-6 bg-gray-50 rounded-lg shadow-sm">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Ajouter un nouveau document</h2>
            <div class="flex flex-col gap-4">
                <input type="text" id="documentNameInput" placeholder="Nom du document ou du cours"
                        class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                
                <select id="documentCategorySelect" class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="">S√©lectionner une cat√©gorie</option>
                </select>
                <select id="documentSubcategorySelect" class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                    <option value="">S√©lectionner une sous-cat√©gorie</option>
                </select>

                <textarea id="documentContentInput" placeholder="Contenu du document (notes, concepts cl√©s...)"
                                rows="6" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y"></textarea>
                
                <div class="mt-2 p-3 bg-blue-50 rounded-lg border border-blue-200">
                    <label for="aiDocumentActionSelect" class="block text-sm font-medium text-blue-800 mb-2">Action AI sur le contenu (avant ajout) :</label>
                    <select id="aiDocumentActionSelect" class="p-2 border border-blue-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="none">Ne rien faire (laisser normal)</option>
                        <option value="develop">D√©velopper/Cr√©er le cours (√† partir d'une id√©e)</option>
                        <option value="optimize">Optimiser/Simplifier le cours (contenu existant)</option>
                    </select>
                </div>
                <div id="aiDocumentActionLoading" class="flex justify-center items-center py-2 hidden">
                    <div class="loading-spinner"></div>
                    <p class="ml-2 text-blue-600">L'IA travaille sur votre contenu...</p>
                </div>
                <button id="addDocumentBtn" class="btn btn-primary">‚ûï Ajouter le document</button>
            </div>
            <div class="mt-4">
                <button id="manageCategoriesBtn" class="btn btn-secondary w-full">‚öôÔ∏è G√©rer les Cat√©gories</button>
            </div>
        </div>
        <div class="flex flex-col md:flex-row md:justify-between md:items-center mb-6 gap-4">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">RVsion - R√©p√©tition Espac√©e & Tests AI</h1>
            <div class="flex flex-col sm:flex-row gap-2 sm:items-center">
                <input type="password" id="apiKeyInput" placeholder="Cl√© API Gemini" 
                    class="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 w-full sm:w-auto">
                <button id="saveApiKeyBtn" class="btn btn-primary mobile-btn-small">üíæ Sauver</button>
            </div>
        </div>

        <div class="mb-8 p-6 bg-blue-50 rounded-lg shadow-sm">
            <h2 class="text-2xl font-semibold text-blue-700 mb-4">Documents √† r√©viser aujourd'hui</h2>
            <div id="documentsDueToday" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <p id="noDocumentsDue" class="text-gray-600 italic">Aucun document √† r√©viser aujourd'hui. Bravo !</p>
            </div>
        </div>

        <div class="mb-8 p-6 bg-purple-50 rounded-lg shadow-sm">
            <h2 class="text-2xl font-semibold text-purple-700 mb-4">Mes Tests AI (En attente/En cours)</h2>
            <div id="aiTestsSavedList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <p id="noAITestsSaved" class="text-gray-600 italic">Aucun test AI en attente. G√©n√©rez-en un !</p>
            </div>
        </div>

        <div class="p-6 bg-gray-50 rounded-lg shadow-sm">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Tous mes documents</h2>
            <div class="mb-4 flex flex-col sm:flex-row gap-4 items-center">
                <input type="text" id="searchDocumentInput" placeholder="Rechercher un document..."
                        class="p-2 border border-gray-300 rounded-lg flex-grow focus:outline-none focus:ring-2 focus:ring-blue-500">
                <select id="filterStatusSelect" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="all">Tous les statuts</option>
                    <option value="due">√Ä r√©viser aujourd'hui</option>
                    <option value="not-due">Non dus</option>
                </select>
                <select id="filterCategorySelect" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="all">Toutes cat√©gories</option>
                </select>
                <select id="filterSubcategorySelect" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                    <option value="all">Toutes sous-cat√©gories</option>
                </select>
            </div>
            <div id="allDocumentsList" class="grid grid-cols-1 gap-4">
                <p id="noDocumentsYet" class="text-gray-600 italic">Vous n'avez pas encore ajout√© de documents.</p>
            </div>
        </div>

        <div class="mt-8 p-6 bg-gray-50 rounded-lg shadow-sm flex flex-col sm:flex-row justify-between items-center gap-4">
            <h2 class="text-2xl font-semibold text-gray-700">Outils de gestion des donn√©es</h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <button id="exportDataBtn" class="btn btn-secondary">üì• Exporter les donn√©es</button>
                <input type="file" id="importFileInput" accept=".json" class="hidden">
                <button id="importDataBtn" class="btn btn-secondary">üì§ Importer les donn√©es</button>
            </div>
        </div>
    </div>

    <!-- Modale de R√©vision -->
    <div id="reviewModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">R√©vision de : <span id="modalDocumentName" class="font-bold text-blue-600"></span></h3>
            <div id="modalDocumentContent" class="document-content-display"></div>
            
            <div class="mt-6 p-4 bg-gray-100 rounded-lg border border-gray-200">
                <h4 class="text-lg font-semibold text-gray-700 mb-3">Posez une question √† l'IA sur ce cours</h4>
                <div id="aiChatDisplay" class="h-40 overflow-y-auto bg-white p-3 rounded-lg border border-gray-300 mb-3 flex flex-col space-y-2 text-sm">
                    <p class="text-gray-500 italic text-center">Posez votre premi√®re question !</p>
                </div>
                <div id="aiChatLoading" class="flex justify-center items-center py-2 hidden">
                    <div class="loading-spinner"></div>
                    <p class="ml-2 text-blue-600">L'IA r√©fl√©chit...</p>
                </div>
                <div class="flex gap-2 mt-3">
                    <input type="text" id="aiChatInput" placeholder="Votre question ici..."
                               class="p-2 border border-gray-300 rounded-lg flex-grow focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="sendAIChatBtn" class="btn btn-primary">Envoyer</button>
                </div>
            </div>
            <p class="text-gray-600 mb-6 mt-6">√âvaluez la facilit√© de la r√©vision (1 = Oubli√©, 5 = Tr√®s facile)</p>
            <div class="flex justify-around gap-2 mb-6">
                <button class="score-button bg-red-100 text-red-700" data-score="1">1</button>
                <button class="score-button bg-orange-100 text-orange-700" data-score="2">2</button>
                <button class="score-button bg-yellow-100 text-yellow-700" data-score="3">3</button>
                <button class="score-button bg-lime-100 text-lime-700" data-score="4">4</button>
                <button class="score-button bg-green-100 text-green-700" data-score="5">5</button>
            </div>
            <div class="flex justify-end gap-4">
                <button id="cancelReviewBtn" class="btn btn-secondary">Annuler</button>
                <button id="submitReviewBtn" class="btn btn-primary" disabled>Soumettre l'√©valuation</button>
            </div>
        </div>
    </div>

    <!-- Modale de configuration du test AI -->
    <div id="testConfigModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Pr√©parer le Test AI pour : <span id="testConfigDocumentName" class="font-bold text-blue-600"></span></h3>
            <div id="testConfigInputs" class="flex flex-col gap-4 mb-6">
                <div>
                    <label for="studyLevelInput" class="block text-sm font-medium text-gray-700 mb-1">Niveau d'√©tude :</label>
                    <select id="studyLevelInput" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="">S√©lectionner un niveau</option>
                        <option value="Primaire">Primaire</option>
                        <option value="Coll√®ge">Coll√®ge</option>
                        <option value="Lyc√©e">Lyc√©e</option>
                        <option value="Universit√©">Universit√©</option>
                        <option value="Professionnel">Professionnel</option>
                        <option value="Autre">Autre</option>
                    </select>
                </div>
                <div>
                    <label for="difficultyInput" class="block text-sm font-medium text-gray-700 mb-1">Niveau de difficult√© du test :</label>
                    <select id="difficultyInput" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="Tr√®s facile">Tr√®s facile</option>
                        <option value="Facile">Facile</option>
                        <option value="Moyen">Moyen</option>
                        <option value="Difficile">Difficile</option>
                        <option value="Tr√®s difficile">Tr√®s difficile</option>
                    </select>
                </div>
                <div>
                    <label for="questionTypeInput" class="block text-sm font-medium text-gray-700 mb-1">Type de questions :</label>
                    <select id="questionTypeInput" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="qcm">QCM (Questions √† Choix Multiples)</option>
                        <option value="written">Questions √âcrites (R√©ponse Libre)</option>
                        <option value="mixed">Mixte (QCM et √âcrites)</option>
                    </select>
                </div>
                <div>
                    <label for="numQuestionsInput" class="block text-sm font-medium text-gray-700 mb-1">Nombre de questions (1-20) :</label>
                    <input type="number" id="numQuestionsInput" value="5" min="1" max="20"
                               class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="additionalContextInput" class="block text-sm font-medium text-gray-700 mb-1">Contexte ou instructions suppl√©mentaires pour l'IA :</label>
                    <textarea id="additionalContextInput" placeholder="Ex: Pose des questions √† choix multiples, Concentre-toi sur les dates..."
                                rows="3" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y"></textarea>
                </div>
            </div>
            <div class="flex justify-end gap-4">
                <button id="cancelTestConfigBtn" class="btn btn-secondary">Annuler</button>
                <button id="prepareInteractiveTestBtn" class="btn btn-primary">‚ú® Pr√©parer le Test Interactif</button> </div>
        </div>
    </div>

    <!-- Modale pour r√©pondre au test AI (Interactive Quiz) -->
    <div id="doTestModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Test Interactif AI pour : <span id="doTestDocumentName" class="font-bold text-blue-600"></span></h3>
            
            <div id="quizGenerationLoading" class="flex justify-center items-center py-8 hidden">
                <div class="loading-spinner"></div>
                <p class="ml-4 text-gray-600">G√©n√©ration du test interactif par l'IA...</p>
            </div>

            <div id="quizDisplayArea" class="hidden">
                <div class="flex justify-between items-center mb-4">
                    <span class="text-lg font-semibold text-gray-700">Question <span id="currentQuestionNumber">1</span>/<span id="totalQuestions">X</span></span>
                    <span class="text-lg font-semibold text-gray-700">Temps √©coul√© : <span id="testTimer" class="font-bold text-blue-600">00:00:00</span></span>
                </div>

                <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <p id="quizQuestionText" class="text-lg font-medium text-gray-800 mb-4"></p>
                    <div id="quizQuestionOptions" class="flex flex-col space-y-3">
                        </div>
                    <div id="quizWrittenAnswerArea" class="hidden">
                        <textarea id="quizWrittenAnswerInput" placeholder="Votre r√©ponse ici..."
                                    rows="6" class="p-3 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y"></textarea>
                    </div>
                    <div id="quizMatchingArea" class="hidden">
                        <p class="text-sm text-gray-500 italic mt-2">Les questions de type "relier" ne sont pas encore impl√©ment√©es dans cette version.</p>
                    </div>
                </div>

                <div class="flex justify-between items-center mt-6">
                    <button id="prevQuestionBtn" class="btn btn-secondary" disabled>‚Üê Pr√©c√©dent</button>
                    <div class="flex gap-2">
                        <button id="startQuizTimerBtn" class="btn btn-success">‚ñ∂Ô∏è D√©marrer le Quiz</button>
                        <button id="nextQuestionBtn" class="btn btn-primary hidden">Suivant ‚Üí</button>
                        <button id="submitQuizBtn" class="btn btn-primary hidden">‚úì Terminer le Quiz</button>
                    </div>
                </div>
                <div class="flex justify-center mt-4">
                    <button id="saveAndQuitQuizBtn" class="btn btn-secondary">üíæ Sauvegarder et Quitter</button>
                </div>


                <div id="quizEvaluationArea" class="hidden mt-8 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                    <h4 class="text-lg font-semibold text-gray-700 mb-2">R√©sultats du Quiz :</h4>
                    <div id="quizResultsSummary" class="text-gray-800 mb-4 document-content-display"></div>
                    
                    <h4 class="text-lg font-semibold text-gray-700 mb-2">√âvaluation D√©taill√©e de l'IA :</h4>
                    <div id="quizAIEvaluation" class="text-gray-800 mb-4 document-content-display bg-blue-50 border-blue-200"></div>
                    <div id="quizCorrectionContent" class="text-gray-800 mb-4 document-content-display bg-green-50 border-green-200"></div>

                    <div class="flex justify-end gap-4 mt-6">
                        <button id="closeQuizResultsBtn" class="btn btn-secondary">Fermer</button>
                        <button id="reEvaluateUnderstandingBtn" class="btn btn-primary hidden">√âvaluer ma compr√©hension (1-5)</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modale de correction (non utilis√©e directement par le quiz interactif actuel) -->
    <div id="correctionModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Corrig√© pour : <span id="correctionDocumentName" class="font-bold text-blue-600"></span></h3>
            <div id="correctionLoading" class="flex justify-center items-center py-8 hidden">
                <div class="loading-spinner"></div>
                <p class="ml-4 text-gray-600">G√©n√©ration du corrig√© par l'IA...</p>
            </div>
            <div id="correctionContent" class="document-content-display"></div>
            <div class="flex justify-end gap-4 mt-6">
                <button id="closeCorrectionBtn" class="btn btn-primary">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modale de gestion des cat√©gories -->
    <div id="categoryManagementModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">G√©rer les Cat√©gories et Sous-cat√©gories</h3>
            <div class="mb-4">
                <h4 class="text-lg font-semibold text-gray-700 mb-2">Ajouter une nouvelle cat√©gorie</h4>
                <div class="flex gap-2">
                    <input type="text" id="newCategoryNameInput" placeholder="Nom de la cat√©gorie" class="p-2 border rounded-lg flex-grow">
                    <button id="addCategoryBtn" class="btn btn-primary">‚ûï Ajouter</button>
                </div>
            </div>
            <div class="mb-4">
                <h4 class="text-lg font-semibold text-gray-700 mb-2">Cat√©gories existantes</h4>
                <ul id="categoriesList" class="space-y-3">
                    </ul>
            </div>
            <div class="flex justify-end gap-4">
                <button id="closeCategoryManagementBtn" class="btn btn-secondary">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modale de confirmation personnalis√©e -->
    <div id="confirmModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4" id="confirmTitle">Confirmer</h3>
            <p class="text-gray-600 mb-6" id="confirmMessage">√ätes-vous s√ªr ?</p>
            <div class="flex justify-end gap-4">
                <button id="cancelConfirmBtn" class="btn btn-secondary">Annuler</button>
                <button id="okConfirmBtn" class="btn btn-danger">Confirmer</button>
            </div>
        </div>
    </div>

    <!-- Modale d'alerte personnalis√©e -->
    <div id="customAlertModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4" id="alertTitle">Alerte</h3>
            <p class="text-gray-600 mb-6" id="alertMessage">Ceci est un message d'alerte.</p>
            <div class="flex justify-end">
                <button id="closeAlertBtn" class="btn btn-primary">OK</button>
            </div>
        </div>
    </div>

    <!-- Modale pour les Flashcards -->
    <div id="flashcardModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Flashcards</h3>
            <div id="flashcardLoading" class="flex justify-center items-center py-8 hidden">
                <div class="loading-spinner"></div>
                <p class="ml-4 text-gray-600">G√©n√©ration des flashcards par l'IA...</p>
            </div>
            <div class="flashcard-wrapper mb-6">
                <div id="flashcardCard" class="flashcard-card">
                    <div id="flashcardFront" class="flashcard-front">
                        <div id="flashcardQuestionDisplay" class="flashcard-text-content"></div>
                    </div>
                    <div id="flashcardBack" class="flashcard-back">
                        <div id="flashcardAnswerDisplay" class="flashcard-text-content"></div>
                    </div>
                </div>
            </div>
            <div class="flex justify-center gap-4 mb-6">
                <button id="flipFlashcardBtn" class="btn btn-warning">üîÑ Retourner</button>
            </div>
            <div class="flex flex-col sm:flex-row justify-between items-center mb-6 gap-2">
                <button id="prevFlashcardBtn" class="btn btn-secondary mobile-full-width">‚Üê Pr√©c√©dent</button>
                <span class="text-gray-700 text-center">Flashcard <span id="currentFlashcardIndexDisplay">0</span>/<span id="totalFlashcardsDisplay">0</span></span>
                <button id="nextFlashcardBtn" class="btn btn-secondary mobile-full-width">Suivant ‚Üí</button>
            </div>

            <!-- New: Flashcard Generation and Management Controls -->
            <div class="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                <h4 class="text-lg font-semibold text-blue-800 mb-3">G√©n√©rer/G√©rer les Flashcards</h4>
                <div class="flex flex-col gap-3">
                    <div>
                        <label for="numFlashcardsToGenerateInput" class="block text-sm font-medium text-gray-700 mb-1">Nombre de flashcards √† g√©n√©rer (laissez vide pour l'IA) :</label>
                        <input type="number" id="numFlashcardsToGenerateInput" placeholder="Ex: 10" min="1" class="p-2 border rounded-lg w-full">
                    </div>
                    <button id="generateFlashcardsWithAIButton" class="btn btn-primary">‚ú® G√©n√©rer via IA</button>
                    <button id="openManageFlashcardsModalButton" class="btn btn-secondary">‚öôÔ∏è G√©rer Manuellement</button>
                </div>
            </div>
            <!-- End New -->

            <div class="flex justify-end">
                <button id="closeFlashcardModalBtn" class="btn btn-primary">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modale de gestion des Flashcards (ajout/√©dition) -->
    <div id="manageFlashcardsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">G√©rer les Flashcards pour : <span id="manageFlashcardsDocumentName" class="font-bold text-blue-600"></span></h3>

            <div class="mb-4">
                <h4 class="text-lg font-semibold text-gray-700 mb-2">Ajouter une nouvelle Flashcard</h4>
                <div class="flex flex-col gap-2">
                    <input type="text" id="newFlashcardQuestionInput" placeholder="Question de la flashcard" class="p-2 border rounded-lg">
                    <textarea id="newFlashcardAnswerInput" placeholder="R√©ponse de la flashcard" rows="3" class="p-2 border rounded-lg resize-y"></textarea>
                    <button id="addFlashcardManuallyBtn" class="btn btn-primary">‚ûï Ajouter Manuellement</button>
                </div>
            </div>

            <div class="mb-4">
                <h4 class="text-lg font-semibold text-gray-700 mb-2">Flashcards Existantes</h4>
                <ul id="flashcardsManagementList" class="space-y-3">
                    <!-- Flashcards will be listed here -->
                </ul>
            </div>

            <div class="flex justify-end gap-4">
                <button id="closeManageFlashcardsModalBtn" class="btn btn-secondary">Fermer</button>
            </div>
        </div>
    </div>

    <script>
        // Fonction utilitaire pour formater les dates
        function formatDate(dateString) {
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return new Date(dateString).toLocaleDateString('fr-FR', options);
        }

        // Fonction utilitaire pour formater le temps en HH:MM:SS
        function formatTime(seconds) {
            const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
            const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
            const s = String(seconds % 60).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        // R√©cup√©rer les √©l√©ments du DOM
        const documentNameInput = document.getElementById('documentNameInput');
        const documentCategorySelect = document.getElementById('documentCategorySelect');
        const documentSubcategorySelect = document.getElementById('documentSubcategorySelect');
        const documentContentInput = document.getElementById('documentContentInput');
        const addDocumentBtn = document.getElementById('addDocumentBtn');
        const manageCategoriesBtn = document.getElementById('manageCategoriesBtn');
        const documentsDueTodayContainer = document.getElementById('documentsDueToday');
        const noDocumentsDueMessage = document.getElementById('noDocumentsDue');
        const allDocumentsList = document.getElementById('allDocumentsList');
        const noDocumentsYetMessage = document.getElementById('noDocumentsYet');

        // NEW AI Document Action Elements
        const aiDocumentActionSelect = document.getElementById('aiDocumentActionSelect');
        const aiDocumentActionLoading = document.getElementById('aiDocumentActionLoading');

        // √âl√©ments pour la recherche et le filtrage
        const searchDocumentInput = document.getElementById('searchDocumentInput');
        const filterStatusSelect = document.getElementById('filterStatusSelect');
        const filterCategorySelect = document.getElementById('filterCategorySelect');
        const filterSubcategorySelect = document.getElementById('filterSubcategorySelect');

        // Boutons d'import/export
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataBtn = document.getElementById('importDataBtn');
        const importFileInput = document.getElementById('importFileInput');

        // √âl√©ments de la cl√© API
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');

        // Modale de r√©vision
        const reviewModal = document.getElementById('reviewModal');
        const modalDocumentName = document.getElementById('modalDocumentName');
        const modalDocumentContent = document.getElementById('modalDocumentContent');
        const scoreButtons = document.querySelectorAll('.score-button');
        const cancelReviewBtn = document.getElementById('cancelReviewBtn');
        const submitReviewBtn = document.getElementById('submitReviewBtn');

        // NEW AI Chat elements in reviewModal
        const aiChatDisplay = document.getElementById('aiChatDisplay');
        const aiChatInput = document.getElementById('aiChatInput');
        const sendAIChatBtn = document.getElementById('sendAIChatBtn');
        const aiChatLoading = document.getElementById('aiChatLoading');


        // Modale de configuration du test AI
        const testConfigModal = document.getElementById('testConfigModal');
        const testConfigDocumentName = document.getElementById('testConfigDocumentName');
        const studyLevelInput = document.getElementById('studyLevelInput');
        const difficultyInput = document.getElementById('difficultyInput');
        const questionTypeInput = document.getElementById('questionTypeInput'); 
        const numQuestionsInput = document.getElementById('numQuestionsInput'); 
        const additionalContextInput = document.getElementById('additionalContextInput');
        const cancelTestConfigBtn = document.getElementById('cancelTestConfigBtn');
        const prepareInteractiveTestBtn = document.getElementById('prepareInteractiveTestBtn'); 

        // Modale pour r√©pondre au test AI (Interactive Quiz) - R√©nov√©e
        const doTestModal = document.getElementById('doTestModal');
        const doTestDocumentName = document.getElementById('doTestDocumentName');
        const quizGenerationLoading = document.getElementById('quizGenerationLoading'); 
        const quizDisplayArea = document.getElementById('quizDisplayArea'); 
        const currentQuestionNumber = document.getElementById('currentQuestionNumber'); 
        const totalQuestions = document.getElementById('totalQuestions'); 
        const quizQuestionText = document.getElementById('quizQuestionText'); 
        const quizQuestionOptions = document.getElementById('quizQuestionOptions'); 
        const quizWrittenAnswerArea = document.getElementById('quizWrittenAnswerArea'); 
        const quizWrittenAnswerInput = document.getElementById('quizWrittenAnswerInput'); 
        const quizMatchingArea = document.getElementById('quizMatchingArea'); 
        const prevQuestionBtn = document.getElementById('prevQuestionBtn'); 
        const startQuizTimerBtn = document.getElementById('startQuizTimerBtn'); 
        const nextQuestionBtn = document.getElementById('nextQuestionBtn'); 
        const submitQuizBtn = document.getElementById('submitQuizBtn'); 
        const testTimer = document.getElementById('testTimer');
        const quizEvaluationArea = document.getElementById('quizEvaluationArea'); 
        const quizResultsSummary = document.getElementById('quizResultsSummary'); 
        const quizAIEvaluation = document.getElementById('quizAIEvaluation'); 
        const quizCorrectionContent = document.getElementById('quizCorrectionContent'); 
        const closeQuizResultsBtn = document.getElementById('closeQuizResultsBtn'); 
        const reEvaluateUnderstandingBtn = document.getElementById('reEvaluateUnderstandingBtn'); 
        const saveAndQuitQuizBtn = document.getElementById('saveAndQuitQuizBtn'); 

        const aiTestsSavedList = document.getElementById('aiTestsSavedList');
        const noAITestsSavedMessage = document.getElementById('noAITestsSaved');

        // Modale du corrig√©
        const correctionModal = document.getElementById('correctionModal');
        const correctionDocumentName = document.getElementById('correctionDocumentName');
        const correctionLoading = document.getElementById('correctionLoading');
        const correctionContent = document.getElementById('correctionContent');
        const closeCorrectionBtn = document.getElementById('closeCorrectionBtn');

        // Modale de gestion des cat√©gories
        const categoryManagementModal = document.getElementById('categoryManagementModal');
        const newCategoryNameInput = document.getElementById('newCategoryNameInput');
        const addCategoryBtn = document.getElementById('addCategoryBtn');
        const categoriesList = document.getElementById('categoriesList');
        const closeCategoryManagementBtn = document.getElementById('closeCategoryManagementBtn');

        // Modale de confirmation personnalis√©e
        const confirmModal = document.getElementById('confirmModal');
        const confirmTitle = document.getElementById('confirmTitle');
        const confirmMessage = document.getElementById('confirmMessage');
        const cancelConfirmBtn = document.getElementById('cancelConfirmBtn');
        const okConfirmBtn = document.getElementById('okConfirmBtn');

        // Modale d'alerte personnalis√©e
        const customAlertModal = document.getElementById('customAlertModal');
        const alertTitle = document.getElementById('alertTitle');
        const alertMessage = document.getElementById('alertMessage');
        const closeAlertBtn = document.getElementById('closeAlertBtn');

        // Flashcard elements
        const flashcardModal = document.getElementById('flashcardModal');
        const flashcardCard = document.getElementById('flashcardCard'); // NEW
        const flashcardFront = document.getElementById('flashcardFront'); // NEW
        const flashcardBack = document.getElementById('flashcardBack'); // NEW
        const flashcardQuestionDisplay = document.getElementById('flashcardQuestionDisplay');
        const flashcardAnswerDisplay = document.getElementById('flashcardAnswerDisplay');
        const flipFlashcardBtn = document.getElementById('flipFlashcardBtn');
        const prevFlashcardBtn = document.getElementById('prevFlashcardBtn');
        const nextFlashcardBtn = document.getElementById('nextFlashcardBtn');
        const currentFlashcardIndexDisplay = document.getElementById('currentFlashcardIndexDisplay');
        const totalFlashcardsDisplay = document.getElementById('totalFlashcardsDisplay');
        const closeFlashcardModalBtn = document.getElementById('closeFlashcardModalBtn');
        const flashcardLoading = document.getElementById('flashcardLoading');

        // NEW Flashcard Management Elements
        const manageFlashcardsModal = document.getElementById('manageFlashcardsModal');
        const manageFlashcardsDocumentName = document.getElementById('manageFlashcardsDocumentName');
        const newFlashcardQuestionInput = document.getElementById('newFlashcardQuestionInput');
        const newFlashcardAnswerInput = document.getElementById('newFlashcardAnswerInput');
        const addFlashcardManuallyBtn = document.getElementById('addFlashcardManuallyBtn');
        const flashcardsManagementList = document.getElementById('flashcardsManagementList');
        const closeManageFlashcardsModalBtn = document.getElementById('closeManageFlashcardsModalBtn');
        const numFlashcardsToGenerateInput = document.getElementById('numFlashcardsToGenerateInput'); // New input for number of flashcards
        const generateFlashcardsWithAIButton = document.getElementById('generateFlashcardsWithAIButton'); // Button to trigger generation with count
        const openManageFlashcardsModalButton = document.getElementById('openManageFlashcardsModalButton'); // Button to open manage flashcards modal


        let currentFlashcards = [];
        let currentFlashcardIndex = 0;
        let isFlashcardFlipped = false;
        let currentManagingDocumentId = null; // To track which document's flashcards are being managed


        let documents = [];
        let categories = [];

        let currentReviewingDocumentId = null;
        let selectedScore = null;
        let currentDocumentForTest = null; 
        let currentAITestBeingAnswered = null; 
        let timerInterval;
        let secondsElapsed = 0;

        let currentQuestionIndex = 0; 

        let editingDocumentId = null; // New global variable to track document being edited


        // API Key pour Gemini (sera charg√©e depuis localStorage)
        let apiKey = ""; 

        /**
         * Charge la cl√© API Gemini depuis le localStorage.
         */
        function loadApiKeyFromLocalStorage() {
            const storedApiKey = localStorage.getItem('geminiApiKey');
            if (storedApiKey) {
                apiKey = storedApiKey;
                apiKeyInput.value = storedApiKey;
                console.log("Cl√© API charg√©e depuis localStorage.");
            } else {
                console.log("Aucune cl√© API trouv√©e dans localStorage.");
            }
        }

        /**
         * Affiche une modale d'alerte personnalis√©e.
         * @param {string} message Le message √† afficher dans l'alerte.
         * @param {string} [title='Alerte'] Le titre de l'alerte.
         * @param {string} [type='info'] Le type d'alerte ('info', 'success', 'error', 'warning').
         */
        function showAlert(message, title = 'Alerte', type = 'info') {
            alertTitle.textContent = title;
            alertMessage.textContent = message;
            customAlertModal.classList.remove('hidden');

            const alertParagraph = customAlertModal.querySelector('#alertMessage');
            alertParagraph.className = 'text-gray-600 mb-6';
            const alertClasses = ['alert-message'];
            if (type === 'success') {
                alertClasses.push('alert-success');
            } else if (type === 'error') {
                alertClasses.push('alert-error');
            } else if (type === 'warning') {
                alertClasses.push('alert-warning');
            } else {
                alertClasses.push('alert-info');
            }
            alertParagraph.className = alertClasses.join(' ');
        }

        /**
         * Affiche une modale de confirmation personnalis√©e.
         * @param {string} message Le message de confirmation.
         * @param {string} [title='Confirmer'] Le titre de la modale.
         * @returns {Promise<boolean>} Une promesse qui se r√©sout √† true si confirm√©, false sinon.
         */
        function showConfirm(message, title = 'Confirmer') {
            return new Promise((resolve) => {
                confirmTitle.textContent = title;
                confirmMessage.textContent = message;
                confirmModal.classList.remove('hidden');

                const handleConfirm = () => {
                    confirmModal.classList.add('hidden');
                    okConfirmBtn.removeEventListener('click', handleConfirm);
                    cancelConfirmBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                const handleCancel = () => {
                    confirmModal.classList.add('hidden');
                    okConfirmBtn.removeEventListener('click', handleConfirm);
                    cancelConfirmBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                okConfirmBtn.addEventListener('click', handleConfirm);
                cancelConfirmBtn.addEventListener('click', handleCancel);
            });
        }

        function loadDocuments() {
            try {
                const storedDocs = localStorage.getItem('forgettingCurveDocuments');
                if (storedDocs) {
                    documents = JSON.parse(storedDocs);
                    documents.forEach(doc => {
                        doc.lastReviewed = new Date(doc.lastReviewed);
                        doc.nextReview = new Date(doc.nextReview);
                        doc.category = doc.category || 'Non class√©';
                        doc.subcategory = doc.subcategory || 'Non class√©';

                        if (doc.aiTests) {
                            doc.aiTests.forEach(test => {
                                test.generatedAt = new Date(test.generatedAt);
                                if (test.startTime) test.startTime = new Date(test.startTime);
                                if (test.endTime) test.endTime = new Date(test.endTime);
                                test.config = test.config || {}; 
                                test.config.difficulty = test.config.difficulty || 'Moyen';
                                test.config.questionType = test.config.questionType || 'qcm'; 
                                test.config.numQuestions = test.config.numQuestions || 5; 
                                test.currentQuestionIndex = test.currentQuestionIndex !== undefined ? test.currentQuestionIndex : 0;
                                if (typeof test.content === 'string' && !test.structuredContent) {
                                    test.structuredContent = null; 
                                }
                                delete test.config.generalTheme;
                                delete test.config.specificTheme;
                            });
                        }
                        doc.aiChatHistory = doc.aiChatHistory || [];
                        doc.flashcards = doc.flashcards || []; 
                        // Removed synthesis related initialization
                    });
                }

                const storedCategories = localStorage.getItem('rvsionCategories');
                if (storedCategories) {
                    categories = JSON.parse(storedCategories);
                }
            } catch (e) {
                console.error("Erreur lors du chargement des donn√©es depuis localStorage:", e);
                showAlert("Impossible de charger les donn√©es. Le stockage local est peut-√™tre bloqu√© ou corrompu. Assurez-vous d'acc√©der √† l'application via un serveur HTTP.", "Erreur de chargement des donn√©es", "error");
                documents = [];
                categories = [];
            }
            populateCategorySelectors();
            populateFilterCategorySelectors();
            renderDocuments();
            renderAITests();
            initGlobalEventListeners(); 
        }

        function saveDocuments() {
            try {
                localStorage.setItem('forgettingCurveDocuments', JSON.stringify(documents));
                localStorage.setItem('rvsionCategories', JSON.stringify(categories));
            } catch (e) {
                console.error("Erreur lors de la sauvegarde des donn√©es dans localStorage:", e);
                showAlert("Impossible de sauvegarder les donn√©es. Le stockage local est peut-√™tre bloqu√© ou plein. Vos changements pourraient ne pas √™tre conserv√©s.", "Erreur de sauvegarde des donn√©es", "warning");
            }
        }

        function calculateNextReview(doc, q) {
            let ef = doc.easeFactor;
            let n = doc.consecutiveSuccessfulReviews;
            let interval = doc.currentInterval;

            if (q >= 3) {
                if (n === 0) {
                    interval = 1;
                } else if (n === 1) {
                    interval = 6;
                } else {
                    interval = Math.round(interval * ef);
                }
                n++;
            } else {
                n = 0;
                interval = 1;
            }

            ef = ef + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02));
            if (ef < 1.3) {
                ef = 1.3;
            }

            doc.easeFactor = ef;
            doc.consecutiveSuccessfulReviews = n;
            doc.currentInterval = interval;
            doc.lastReviewed = new Date();

            const nextReviewDate = new Date();
            nextReviewDate.setDate(nextReviewDate.getDate() + interval);
            doc.nextReview = nextReviewDate;
            saveDocuments();
        }

        function renderDocuments() {
            documentsDueTodayContainer.innerHTML = '';
            allDocumentsList.innerHTML = '';
            noDocumentsDueMessage.style.display = 'none';
            noDocumentsYetMessage.style.display = 'none';

            if (documents.length === 0) {
                noDocumentsYetMessage.style.display = 'block';
                noDocumentsDueMessage.style.display = 'block';
                return;
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let documentsDueCount = 0;
            const searchTerm = searchDocumentInput.value.toLowerCase();
            const filterStatus = filterStatusSelect.value;
            const filterCategory = filterCategorySelect.value === 'all' ? null : categories.find(cat => cat.id === filterCategorySelect.value)?.name;
            const filterSubcategory = filterSubcategorySelect.value === 'all' ? null : categories.find(cat => cat.id === filterCategorySelect.value)?.subcategories.find(sub => sub.id === filterSubcategorySelect.value)?.name;

            const filteredDocuments = documents.filter(doc => {
                const matchesSearch = doc.name.toLowerCase().includes(searchTerm) || 
                                        doc.content.toLowerCase().includes(searchTerm) ||
                                        (doc.category && doc.category.toLowerCase().includes(searchTerm)) || 
                                        (doc.subcategory && doc.subcategory.toLowerCase().includes(searchTerm)); 
                
                const nextReviewDate = new Date(doc.nextReview);
                nextReviewDate.setHours(0, 0, 0, 0);
                const isDueToday = nextReviewDate <= today;

                let matchesStatus = true;
                if (filterStatus === 'due') {
                    matchesStatus = isDueToday;
                } else if (filterStatus === 'not-due') {
                    matchesStatus = !isDueToday;
                }

                let matchesCategory = true;
                if (filterCategory) {
                    matchesCategory = doc.category === filterCategory;
                }

                let matchesSubcategory = true;
                if (filterSubcategory) {
                    matchesSubcategory = doc.subcategory === filterSubcategory;
                }

                return matchesSearch && matchesStatus && matchesCategory && matchesSubcategory;
            });

            if (filteredDocuments.length === 0 && (searchTerm.length > 0 || filterStatus !== 'all' || filterCategory !== null || filterSubcategory !== null)) {
                allDocumentsList.innerHTML = '<p class="text-gray-600 italic">Aucun document ne correspond √† vos crit√®res de recherche/filtre.</p>';
            } else if (filteredDocuments.length === 0 && searchTerm.length === 0 && filterStatus === 'all' && filterCategory === null && filterSubcategory === null) {
                    noDocumentsYetMessage.style.display = 'block';
                    allDocumentsList.innerHTML = ''; 
            } else if (filteredDocuments.length === 0) {
                allDocumentsList.innerHTML = '<p class="text-gray-600 italic">Aucun document ne correspond √† vos crit√®res de recherche/filtre.</p>';
            }

            filteredDocuments.forEach(doc => {
                const nextReviewDate = new Date(doc.nextReview);
                nextReviewDate.setHours(0, 0, 0, 0);

                const isDueToday = nextReviewDate <= today;

                const card = document.createElement('div');
                card.className = `p-4 rounded-lg shadow-md flex flex-col justify-between ${isDueToday ? 'bg-blue-100 border border-blue-300' : 'bg-white border border-gray-200'}`;
                card.innerHTML = `
                    <h3 class="text-lg font-semibold mb-2 text-gray-900">${doc.name}</h3>
                    <p class="text-sm text-gray-600">Cat√©gorie: ${doc.category || 'Non class√©'} | Sous-cat√©gorie: ${doc.subcategory || 'Non class√©'}</p>
                    <p class="text-sm text-gray-600">Derni√®re r√©vision: ${formatDate(doc.lastReviewed)}</p>
                    <p class="text-sm text-gray-600">Prochaine r√©vision: <span class="font-medium ${isDueToday ? 'text-blue-700' : 'text-gray-700'}">${formatDate(doc.nextReview)}</span></p>
                    <p class="text-xs text-gray-500 mt-1">EF: ${doc.easeFactor.toFixed(2)} | Intervalle: ${doc.currentInterval} jours | R√©visions r√©ussies: ${doc.consecutiveSuccessfulReviews}</p>
                    <div class="mt-4 flex justify-end gap-2 flex-wrap">
                        <button data-id="${doc.id}" class="btn btn-success review-btn">üìù R√©viser</button>
                        <button data-id="${doc.id}" class="btn btn-warning test-ai-btn">‚ú® Test (IA)</button>
                        <button data-id="${doc.id}" class="btn btn-info flashcards-btn">üóÇÔ∏è Flashcards</button>
                        <button data-id="${doc.id}" class="btn btn-info edit-document-btn">‚úèÔ∏è Modifier</button>
                        <button data-id="${doc.id}" class="btn btn-danger delete-btn">üóëÔ∏è Supprimer</button>
                    </div>
                `;

                if (isDueToday) {
                    documentsDueTodayContainer.appendChild(card.cloneNode(true));
                    documentsDueCount++;
                }
                allDocumentsList.appendChild(card);
            });

            if (documentsDueCount === 0) {
                noDocumentsDueMessage.style.display = 'block';
            } else {
                noDocumentsDueMessage.style.display = 'none';
            }
            if (documents.length > 0) {
                noDocumentsYetMessage.style.display = 'none';
            }

            addDocumentEventListeners();
        }

        function renderAITests() {
            aiTestsSavedList.innerHTML = '';
            noAITestsSavedMessage.style.display = 'block';

            let aiTestsCount = 0;
            documents.forEach(doc => {
                if (doc.aiTests && doc.aiTests.length > 0) {
                    // Sort tests by generation date, newest first
                    doc.aiTests.sort((a, b) => new Date(b.generatedAt) - new Date(a.generatedAt));

                    doc.aiTests.forEach(aiTest => {
                        // N'afficher que les tests 'pending' ou 'in_progress' ou 'completed'
                        if (aiTest.status === 'pending' || aiTest.status === 'in_progress' || aiTest.status === 'completed') {
                            noAITestsSavedMessage.style.display = 'none';
                            aiTestsCount++;
                            const testCard = document.createElement('div');
                            testCard.className = `p-4 rounded-lg shadow-md flex flex-col justify-between bg-purple-100 border border-purple-300`;
                            
                            let statusText = '';
                            let statusClass = '';
                            if (aiTest.status === 'pending') {
                                statusText = 'En attente';
                                statusClass = 'text-purple-700';
                            } else if (aiTest.status === 'in_progress') {
                                statusText = 'En cours';
                                statusClass = 'text-orange-700';
                            } else if (aiTest.status === 'completed') {
                                statusText = 'Termin√©';
                                statusClass = 'text-green-700';
                            }

                            let durationText = aiTest.duration ? `Dur√©e: ${formatTime(aiTest.duration)}` : '';
                            let scoreText = aiTest.aiScore ? `Note AI: ${aiTest.aiScore}/5` : '';
                            let typeText = '';
                            if (aiTest.config.questionType === 'qcm') typeText = ' (QCM)';
                            else if (aiTest.config.questionType === 'written') typeText = ' (√âcrit)';
                            else if (aiTest.config.questionType === 'mixed') typeText = ' (Mixte)';
                            else typeText = ' (Interactif)';


                            testCard.innerHTML = `
                                <h3 class="text-lg font-semibold mb-2 text-gray-900">Test AI pour : ${doc.name}</h3>
                                <p class="text-sm text-gray-600">Type: ${typeText} | Questions: ${aiTest.structuredContent?.questions?.length || 'N/A'} | G√©n√©r√©: ${formatDate(aiTest.generatedAt)}</p>
                                <p class="text-sm text-gray-600">Difficult√©: ${aiTest.config.difficulty || 'Non sp√©cifi√©e'} | Niveau: ${aiTest.config.studyLevel || 'Non sp√©cifi√©'}</p>
                                <p class="text-xs text-gray-500 mt-1">Statut: <span class="font-bold ${statusClass}">${statusText}</span> ${durationText ? `| ${durationText}` : ''} ${scoreText ? `| ${scoreText}` : ''}</p>
                                <div class="mt-4 flex justify-end gap-2">
                                    <button data-doc-id="${doc.id}" data-test-id="${aiTest.id}" class="btn btn-primary do-ai-test-btn">‚ñ∂Ô∏è R√©pondre au Test</button>
                                    <button data-doc-id="${doc.id}" data-test-id="${aiTest.id}" class="btn btn-danger delete-ai-test-btn">üóëÔ∏è Supprimer</button>
                                </div>
                            `;
                            aiTestsSavedList.appendChild(testCard);
                        }
                    });
                }
            });

            if (aiTestsCount === 0) {
                noAITestsSavedMessage.style.display = 'block';
            }
            addAITestEventListeners();
        }

        function populateCategorySelectors() {
            documentCategorySelect.innerHTML = '<option value="">S√©lectionner une cat√©gorie</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                documentCategorySelect.appendChild(option);
            });
            documentSubcategorySelect.innerHTML = '<option value="">S√©lectionner une sous-cat√©gorie</option>';
            documentSubcategorySelect.disabled = true;
        }

        function populateFilterCategorySelectors() {
            filterCategorySelect.innerHTML = '<option value="all">Toutes cat√©gories</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                filterCategorySelect.appendChild(option);
            });
            filterSubcategorySelect.innerHTML = '<option value="all">Toutes sous-cat√©gories</option>';
            filterSubcategorySelect.disabled = true;
        }
        
        addDocumentBtn.addEventListener('click', async () => {
            try {
                // V√©rifier si la cl√© API est pr√©sente
                if (!apiKey) {
                    showAlert("Veuillez d'abord sauvegarder votre cl√© API Gemini. Le traitement AI ne fonctionnera pas sans elle.", "Cl√© API manquante", "warning");
                    return;
                }

                const name = documentNameInput.value.trim();
                const selectedCategoryId = documentCategorySelect.value;
                const selectedSubcategoryId = documentSubcategorySelect.value;
                let content = documentContentInput.value.trim();
                const aiAction = aiDocumentActionSelect.value;

                if (!name) {
                    showAlert('Veuillez entrer un nom pour le document.', 'Champ vide', 'error');
                    return;
                }
                if (!content && (aiAction === 'none' || aiAction === 'optimize')) {
                    showAlert('Veuillez entrer un contenu pour le document si l\'IA ne doit pas le d√©velopper ou l\'optimiser, ou s√©lectionnez "D√©velopper/Cr√©er le cours".', 'Contenu manquant', 'error');
                    return;
                }

                if (aiAction !== 'none') {
                    aiDocumentActionLoading.classList.remove('hidden');
                    addDocumentBtn.disabled = true;
                    try {
                        content = await processDocumentContentWithAI(content, aiAction, name);
                        documentContentInput.value = content;
                        if (!content) {
                            showAlert("L'IA n'a pas pu g√©n√©rer ou optimiser le contenu. Veuillez r√©essayer ou ajuster vos entr√©es.", "√âchec de l'IA", "warning");
                            return;
                        }
                    } catch (aiError) {
                        console.error("Erreur lors du traitement AI du document:", aiError);
                        showAlert("Une erreur est survenue lors du traitement AI du document. Veuillez r√©essayer.", "Erreur AI", "error");
                        return;
                    } finally {
                        aiDocumentActionLoading.classList.add('hidden');
                        addDocumentBtn.disabled = false;
                    }
                }

                let categoryName = 'Non class√©';
                let subcategoryName = 'Non class√©';

                if (selectedCategoryId) {
                    const category = categories.find(cat => cat.id === selectedCategoryId);
                    if (category) {
                        categoryName = category.name;
                        if (selectedSubcategoryId && selectedSubcategoryId !== "") {
                            const subcategory = category.subcategories.find(sub => sub.id === selectedSubcategoryId);
                            if (subcategory) {
                                subcategoryName = subcategory.name;
                            } else {
                                subcategoryName = 'Non class√©';
                            }
                        } else {
                            subcategoryName = 'Non class√©';
                        }
                    } else {
                        categoryName = 'Non class√©';
                        subcategoryName = 'Non class√©';
                    }
                }

                if (editingDocumentId) {
                    // Update existing document
                    const docToUpdate = documents.find(d => d.id === editingDocumentId);
                    if (docToUpdate) {
                        docToUpdate.name = name;
                        docToUpdate.category = categoryName;
                        docToUpdate.subcategory = subcategoryName;
                        docToUpdate.content = content;
                        saveDocuments();
                        renderDocuments();
                        addDocumentBtn.textContent = '‚ûï Ajouter le document'; // Reset button text
                        showAlert('Document modifi√© avec succ√®s !', 'Succ√®s', 'success');
                        editingDocumentId = null; // Clear editing state
                        documentNameInput.value = '';
                        documentCategorySelect.value = '';
                        documentSubcategorySelect.innerHTML = '<option value="">S√©lectionner une sous-cat√©gorie</option>';
                        documentSubcategorySelect.disabled = true;
                        documentContentInput.value = '';
                        aiDocumentActionSelect.value = 'none';
                    }
                } else {
                    // Add new document
                    const newDoc = {
                        id: crypto.randomUUID(),
                        name: name,
                        category: categoryName,
                        subcategory: subcategoryName,
                        content: content,
                        lastReviewed: new Date().toISOString(),
                        nextReview: new Date().toISOString(),
                        easeFactor: 2.5,
                        consecutiveSuccessfulReviews: 0,
                        currentInterval: 0,
                        aiTests: [],
                        aiChatHistory: [],
                        flashcards: [] 
                    };
                    documents.push(newDoc);
                    saveDocuments();
                    renderDocuments();
                    documentNameInput.value = '';
                    documentCategorySelect.value = '';
                    documentSubcategorySelect.innerHTML = '<option value="">S√©lectionner une sous-cat√©gorie</option>';
                    documentSubcategorySelect.disabled = true;
                    documentContentInput.value = '';
                    aiDocumentActionSelect.value = 'none'; 
                    showAlert('Document ajout√© avec succ√®s !', 'Succ√®s', 'success');
                }
            } catch (error) {
                console.error("Erreur lors de l'ajout/modification du document:", error);
                showAlert("Une erreur est survenue lors de l'ajout/modification du document. Veuillez consulter la console pour plus de d√©tails.", "Erreur d'ajout/modification", 'error');
            }
        });

        /**
         * Appelle l'IA pour d√©velopper, optimiser ou simplifier le contenu d'un document.
         * @param {string} originalContent Le contenu initial du document.
         * @param {string} action L'action AI √† effectuer ('develop', 'optimize').
         * @param {string} documentName Le nom du document (pour le contexte de l'IA).
         * @returns {Promise<string>} Le contenu trait√© par l'IA.
         */
        async function processDocumentContentWithAI(originalContent, action, documentName) {
            // V√©rifier si la cl√© API est d√©finie
            if (!apiKey) {
                throw new Error("Cl√© API Gemini non configur√©e. Veuillez la sauvegarder via le champ d√©di√©.");
            }

            let prompt = "";
            if (action === 'develop') {
                prompt = `En tant qu'expert en p√©dagogie, d√©veloppez un cours complet et d√©taill√© sur le sujet "${documentName}".
Si un contenu initial est fourni ("${originalContent}"), utilisez-le comme point de d√©part pour enrichir et structurer le cours.
Le cours doit √™tre clair, bien organis√©, et couvrir les aspects essentiels du sujet pour un apprentissage efficace.
Utilisez le formatage Markdown (titres avec #, ##, etc., listes √† puces avec -, listes num√©rot√©es avec 1., 2., etc., texte en gras avec **). √âvitez les ast√©risques bruts pour les listes.`;
            } else if (action === 'optimize') {
                prompt = `En tant qu'expert en p√©dagogie, optimisez et simplifiez le contenu suivant pour le rendre plus clair, concis et facile √† comprendre.
Adaptez le langage √† un niveau g√©n√©ral d'apprenant. Reformulez les phrases complexes, supprimez les informations redondantes et structurez le texte pour une meilleure lisibilit√©.
Utilisez le formatage Markdown (titres avec #, ##, etc., listes √† puces avec -, listes num√©rot√©es avec 1., 2., etc., texte en gras avec **). √âvitez les ast√©risques bruts pour les listes.
Titre du document : ${documentName}
Contenu √† optimiser :
---
${originalContent}
---
Fournissez uniquement le contenu optimis√©.`;
            } else {
                return originalContent;
            }

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.error('Erreur API lors du traitement AI du document:', response.status, response.statusText, errorData);
                throw new Error(`√âchec de l'IA: ${errorData.error?.message || response.statusText}`);
            } else {
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error('Structure de r√©ponse inattendue de l\'API Gemini pour le traitement du document:', result);
                    throw new Error("L'IA a retourn√© une structure inattendue.");
                }
            }
        }

        // G√©rer les √©couteurs d'√©v√©nements pour tous les boutons des documents
        function addDocumentEventListeners() {
            document.querySelectorAll('.review-btn').forEach(button => {
                button.removeEventListener('click', handleReviewButtonClick);
                button.addEventListener('click', handleReviewButtonClick);
            });
            document.querySelectorAll('.test-ai-btn').forEach(button => {
                button.removeEventListener('click', handleTestAIButtonClick);
                button.addEventListener('click', handleTestAIButtonClick);
            });
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteButtonClick);
                button.addEventListener('click', handleDeleteButtonClick);
            });
            // Add listeners for flashcards
            document.querySelectorAll('.flashcards-btn').forEach(button => {
                button.removeEventListener('click', handleFlashcardsButtonClick);
                button.addEventListener('click', handleFlashcardsButtonClick);
            });
            // Add listener for edit document
            document.querySelectorAll('.edit-document-btn').forEach(button => {
                button.removeEventListener('click', handleEditDocumentButtonClick);
                button.addEventListener('click', handleEditDocumentButtonClick);
            });
            // Removed synthesis button listener
        }

        // G√©rer les √©couteurs d'√©v√©nements pour les tests AI
        function addAITestEventListeners() {
            document.querySelectorAll('.do-ai-test-btn').forEach(button => {
                button.removeEventListener('click', handleDoAITestButtonClick); 
                button.addEventListener('click', handleDoAITestButtonClick);
            });
            document.querySelectorAll('.delete-ai-test-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteAITestButtonClick); 
                button.addEventListener('click', handleDeleteAITestButtonClick);
            });
        }

        // Gestionnaire pour le bouton "R√©viser"
        function handleReviewButtonClick(event) {
            const docId = event.target.dataset.id;
            const doc = documents.find(d => d.id === docId);
            if (doc) {
                currentReviewingDocumentId = docId;
                modalDocumentName.textContent = doc.name;
                // Render Markdown content (if any) or plain text
                const content = doc.content;
                modalDocumentContent.innerHTML = marked.parse(content); 

                reviewModal.classList.remove('hidden');
                scoreButtons.forEach(btn => btn.classList.remove('selected'));
                selectedScore = null;
                submitReviewBtn.disabled = true;

                aiChatDisplay.innerHTML = ''; 
                if (doc.aiChatHistory && doc.aiChatHistory.length > 0) {
                    doc.aiChatHistory.forEach(msg => displayChatMessage(msg.role, msg.text));
                } else {
                    aiChatDisplay.innerHTML = '<p class="text-gray-500 italic text-center">Posez votre premi√®re question !</p>';
                }
                aiChatInput.value = ''; 
                aiChatDisplay.scrollTop = aiChatDisplay.scrollHeight; 
            }
        }

        // Gestionnaire pour le bouton "Test (IA)" (Ouvre la modale de configuration)
        function handleTestAIButtonClick(event) {
            // V√©rifier si la cl√© API est pr√©sente
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre cl√© API Gemini. La pr√©paration du test AI ne fonctionnera pas sans elle.", "Cl√© API manquante", "warning");
                return;
            }

            const docId = event.target.dataset.id;
            const doc = documents.find(d => d.id === docId);
            if (doc) {
                currentDocumentForTest = doc;
                testConfigDocumentName.textContent = doc.name;
                // R√©initialiser les champs de la modale de configuration
                studyLevelInput.value = '';
                difficultyInput.value = 'Moyen'; 
                questionTypeInput.value = 'qcm';
                numQuestionsInput.value = '5'; 
                additionalContextInput.value = '';
                testConfigModal.classList.remove('hidden');
            }
        }

        prepareInteractiveTestBtn.addEventListener('click', async () => {
            // V√©rifier si la cl√© API est pr√©sente
            if (!apiKey) {
                showAlert("Cl√© API Gemini non configur√©e. Impossible de g√©n√©rer le test AI.", "Cl√© API manquante", "error");
                return;
            }

            if (!currentDocumentForTest) {
                showAlert("Erreur: Aucun document s√©lectionn√© pour pr√©parer le test.", "Erreur", 'error');
                return;
            }

            const numQuestions = parseInt(numQuestionsInput.value);
            if (isNaN(numQuestions) || numQuestions < 1 || numQuestions > 20) {
                showAlert("Veuillez entrer un nombre de questions valide entre 1 et 20.", "Nombre de questions invalide", "error");
                return;
            }

            testConfigModal.classList.add('hidden');
            doTestModal.classList.remove('hidden');

            currentQuestionIndex = 0;
            clearInterval(timerInterval);
            secondsElapsed = 0;
            testTimer.textContent = formatTime(secondsElapsed);
            startQuizTimerBtn.classList.remove('hidden');
            nextQuestionBtn.classList.add('hidden');
            prevQuestionBtn.classList.add('hidden');
            submitQuizBtn.classList.add('hidden');
            saveAndQuitQuizBtn.classList.add('hidden'); 
            quizDisplayArea.classList.add('hidden');
            quizEvaluationArea.classList.add('hidden');
            
            quizGenerationLoading.classList.remove('hidden'); 

            doTestDocumentName.textContent = currentDocumentForTest.name;

            const studyLevel = studyLevelInput.value.trim();
            const difficulty = difficultyInput.value.trim();
            const questionType = questionTypeInput.value; 
            const additionalContext = additionalContextInput.value.trim();

            try {
                let prompt = `En tant qu'expert en p√©dagogie, cr√©ez un quiz interactif bas√© sur le document suivant.
                Le quiz doit √™tre compos√© de ${numQuestions} questions.
                `;

                let responseSchema = {
                    type: "OBJECT",
                    properties: {
                        "quizTitle": { "type": "STRING" },
                        "questions": {
                            "type": "ARRAY",
                            "items": {
                                "type": "OBJECT",
                                "properties": {
                                    "id": { "type": "STRING" },
                                    "type": { "type": "STRING", "enum": ["qcm", "written", "matching"] }, 
                                    "text": { "type": "STRING" },
                                    "options": { 
                                        "type": "ARRAY",
                                        "items": {
                                            "type": "OBJECT",
                                            "properties": {
                                                "id": { "type": "STRING" },
                                                "text": { "type": "STRING" }
                                            },
                                            "required": ["id", "text"]
                                        }
                                    },
                                    "correctAnswerId": { "type": "STRING" }, 
                                    "correctAnswerText": { "type": "STRING" } 
                                },
                                "required": ["id", "type", "text"], 
                                "propertyOrdering": ["id", "type", "text", "options", "correctAnswerId", "correctAnswerText"]
                            }
                        }
                    },
                    "required": ["quizTitle", "questions"],
                    "propertyOrdering": ["quizTitle", "questions"]
                };


                if (questionType === 'qcm' || questionType === 'mixed') {
                    prompt += ` Pour les questions √† choix multiples (QCM), chaque question doit avoir 4 options de r√©ponse, et une seule doit √™tre correcte. La r√©ponse correcte doit √™tre clairement indiqu√©e par son ID.`;
                }
                if (questionType === 'written' || questionType === 'mixed') {
                    prompt += ` Pour les questions √©crites, fournissez la r√©ponse correcte sous forme de texte dans le champ 'correctAnswerText'.`;
                }

                if (questionType === 'qcm') {
                    prompt += ` Toutes les questions doivent √™tre des QCM.`;
                } else if (questionType === 'written') {
                    prompt += ` Toutes les questions doivent √™tre des questions √©crites (r√©ponse libre).`;
                } else if (questionType === 'mixed') {
                    prompt += ` Le quiz doit inclure un m√©lange de questions QCM et de questions √©crites.`;
                }


                prompt += `
Titre du document : ${currentDocumentForTest.name}
Cat√©gorie du document : ${currentDocumentForTest.category || 'Non sp√©cifi√©e'}
Sous-cat√©gorie du document : ${currentDocumentForTest.subcategory || 'Non sp√©cifi√©e'}
Contenu du document :
---
${currentDocumentForTest.content}
---

Informations suppl√©mentaires pour adapter le test :
Niveau d'√©tude de l'apprenant : ${studyLevel || 'Non sp√©cifi√©'}
Niveau de difficult√© souhait√© pour le test : ${difficulty || 'Moyen'}
Nombre de questions : ${numQuestions}
Contexte ou instructions suppl√©mentaires : ${additionalContext || 'Aucun'}
`; 
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { 
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema 
                    }
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Erreur API lors de la g√©n√©ration du quiz interactif:', response.status, response.statusText, errorData);
                    showAlert(`Erreur lors de la g√©n√©ration du quiz: ${response.status}. Veuillez r√©essayer. D√©tails: ${errorData.error?.message || 'Inconnu'}`, 'Erreur AI', 'error');
                    quizGenerationLoading.classList.add('hidden');
                    doTestModal.classList.add('hidden'); 
                } else {
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        try {
                            const quizData = JSON.parse(result.candidates[0].content.parts[0].text);
                            if (quizData.questions && Array.isArray(quizData.questions) && quizData.questions.length > 0) {
                                const newAITest = {
                                    id: crypto.randomUUID(),
                                    generatedAt: new Date().toISOString(),
                                    content: `Test Interactif (${questionTypeInput.value} - ${numQuestions} questions)`, 
                                    structuredContent: quizData, 
                                    config: {
                                        studyLevel: studyLevel,
                                        difficulty: difficulty,
                                        questionType: questionType, 
                                        numQuestions: numQuestions, 
                                        additionalContext: additionalContext,
                                    },
                                    status: 'pending', 
                                    startTime: null,
                                    endTime: null,
                                    duration: null,
                                    userAnswers: Array(quizData.questions.length).fill(null), 
                                    aiEvaluation: null,
                                    aiScore: null,
                                    correction: null,
                                    currentQuestionIndex: 0 
                                };
                                const docIndex = documents.findIndex(d => d.id === currentDocumentForTest.id);
                                if (!documents[docIndex].aiTests) {
                                    documents[docIndex].aiTests = [];
                                }
                                documents[docIndex].aiTests.push(newAITest);
                                saveDocuments();

                                currentAITestBeingAnswered = newAITest; 
                                totalQuestions.textContent = quizData.questions.length; 
                                renderQuestion(currentQuestionIndex); 
                                quizDisplayArea.classList.remove('hidden');
                                saveAndQuitQuizBtn.classList.remove('hidden'); 
                                showAlert('Quiz interactif g√©n√©r√© avec succ√®s ! Cliquez sur "D√©marrer le Quiz" pour commencer.', 'Succ√®s AI', 'success');
                            } else {
                                showAlert('L\'IA a g√©n√©r√© un quiz vide ou mal format√©. Veuillez r√©essayer.', 'Erreur AI', 'error');
                                doTestModal.classList.add('hidden');
                            }
                        } catch (parseError) {
                            console.error('Erreur lors du parsing JSON du quiz:', parseError);
                            showAlert('L\'IA a retourn√© un format JSON invalide pour le quiz. Veuillez r√©essayer.', 'Erreur de format AI', 'error');
                            doTestModal.classList.add('hidden');
                        }
                    } else {
                        console.error('Structure de r√©ponse inattendue de l\'API Gemini pour le quiz:', result);
                        showAlert('La r√©ponse de l\'IA √©tait inattendue pour le quiz. Veuillez r√©essayer.', 'Erreur AI', 'error');
                        doTestModal.classList.add('hidden');
                    }
                }
            } catch (error) {
                console.error('Erreur lors de l\'appel de l\'API Gemini pour le quiz:', error);
                showAlert('Une erreur est survenue lors de la g√©n√©ration du quiz. Veuillez v√©rifier votre connexion internet ou r√©essayer plus tard.', 'Erreur R√©seau', 'error');
                doTestModal.classList.add('hidden');
            } finally {
                quizGenerationLoading.classList.add('hidden');
            }
        });

        /**
         * Affiche la question actuelle du quiz interactif.
         * @param {number} index L'index de la question √† afficher.
         */
        function renderQuestion(index) {
            const quiz = currentAITestBeingAnswered.structuredContent;
            if (!quiz || !quiz.questions || index < 0 || index >= quiz.questions.length) {
                showAlert("Erreur: Question introuvable.", "Erreur Quiz", "error");
                return;
            }

            const question = quiz.questions[index];
            currentQuestionNumber.textContent = index + 1;
            // Use marked.parse for quiz question text
            quizQuestionText.innerHTML = marked.parse(question.text);
            
            quizQuestionOptions.classList.add('hidden');
            quizWrittenAnswerArea.classList.add('hidden');
            quizMatchingArea.classList.add('hidden');

            if (question.type === 'qcm') {
                quizQuestionOptions.classList.remove('hidden');
                quizQuestionOptions.innerHTML = ''; 
                question.options.forEach(option => {
                    const optionDiv = document.createElement('label');
                    optionDiv.className = 'quiz-option';
                    // Use marked.parse for QCM option text
                    optionDiv.innerHTML = `
                        <input type="radio" name="currentQuestion" value="${option.id}" class="form-radio text-blue-600">
                        <span>${marked.parse(option.text)}</span>
                    `;
                    quizQuestionOptions.appendChild(optionDiv);

                    if (currentAITestBeingAnswered.userAnswers[index] === option.id) {
                        optionDiv.classList.add('selected');
                        optionDiv.querySelector('input').checked = true;
                    }

                    optionDiv.addEventListener('click', () => {
                        if (currentAITestBeingAnswered.status !== 'completed') {
                            quizQuestionOptions.querySelectorAll('.quiz-option').forEach(opt => opt.classList.remove('selected'));
                            optionDiv.classList.add('selected');
                            optionDiv.querySelector('input').checked = true;
                            currentAITestBeingAnswered.userAnswers[index] = option.id;
                            currentAITestBeingAnswered.currentQuestionIndex = index;
                            saveDocuments(); 
                        }
                    });
                });
            } else if (question.type === 'written') {
                quizWrittenAnswerArea.classList.remove('hidden');
                quizWrittenAnswerInput.value = currentAITestBeingAnswered.userAnswers[index] || ''; 
                quizWrittenAnswerInput.oninput = (event) => {
                    if (currentAITestBeingAnswered.status !== 'completed') {
                        currentAITestBeingAnswered.userAnswers[index] = event.target.value;
                        currentAITestBeingAnswered.currentQuestionIndex = index;
                        saveDocuments();
                    }
                };
            } else if (question.type === 'matching') {
                quizMatchingArea.classList.remove('hidden');
            } else {
                quizQuestionText.textContent = `Type de question "${question.type}" non support√© pour l'instant.`;
            }

            prevQuestionBtn.disabled = (index === 0);
            nextQuestionBtn.classList.toggle('hidden', index === quiz.questions.length - 1);
            submitQuizBtn.classList.toggle('hidden', index !== quiz.questions.length - 1);

            if (currentAITestBeingAnswered.status === 'completed') {
                quizQuestionOptions.querySelectorAll('input').forEach(input => input.disabled = true);
                quizWrittenAnswerInput.disabled = true;
                saveAndQuitQuizBtn.classList.add('hidden'); 
            } else {
                quizWrittenAnswerInput.disabled = false;
            }
        }

        function handleDoAITestButtonClick(event) {
            // V√©rifier si la cl√© API est pr√©sente
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre cl√© API Gemini. Le test AI ne fonctionnera pas sans elle.", "Cl√© API manquante", "warning");
                return;
            }

            const docId = event.target.dataset.docId;
            const testId = event.target.dataset.testId;

            const doc = documents.find(d => d.id === docId);
            if (doc && doc.aiTests) {
                const aiTest = doc.aiTests.find(test => test.id === testId);
                if (aiTest) {
                    currentAITestBeingAnswered = aiTest;
                    currentDocumentForTest = doc; 

                    doTestDocumentName.textContent = doc.name;
                    
                    quizGenerationLoading.classList.add('hidden');

                    if (aiTest.structuredContent) { 
                        quizDisplayArea.classList.remove('hidden');
                        quizEvaluationArea.classList.add('hidden'); 
                        totalQuestions.textContent = aiTest.structuredContent.questions.length;
                        
                        currentQuestionIndex = aiTest.currentQuestionIndex !== undefined ? aiTest.currentQuestionIndex : 0;
                        renderQuestion(currentQuestionIndex);

                        clearInterval(timerInterval);
                        secondsElapsed = aiTest.duration || 0; 
                        testTimer.textContent = formatTime(secondsElapsed);
                        
                        // Reset button states
                        startQuizTimerBtn.classList.remove('hidden');
                        startQuizTimerBtn.textContent = '‚ñ∂Ô∏è D√©marrer le Quiz'; // Default text
                        nextQuestionBtn.classList.add('hidden');
                        prevQuestionBtn.classList.add('hidden');
                        submitQuizBtn.classList.add('hidden');
                        saveAndQuitQuizBtn.classList.remove('hidden'); 

                        if (aiTest.status === 'in_progress') {
                            startQuizTimerBtn.textContent = '‚ñ∂Ô∏è Reprendre le Quiz'; // Change text for resuming
                            // Show nav/submit buttons according to current question index and total questions
                            if (aiTest.structuredContent.questions.length > 1) {
                                nextQuestionBtn.classList.remove('hidden');
                                prevQuestionBtn.classList.remove('hidden');
                            }
                            if (currentQuestionIndex === aiTest.structuredContent.questions.length - 1) {
                                submitQuizBtn.classList.remove('hidden');
                                nextQuestionBtn.classList.add('hidden');
                            }
                            // Don't auto-start timer, user must click "Reprendre"
                            showAlert('Quiz interactif en cours. Cliquez sur "Reprendre le Quiz" pour continuer.', 'Reprise du Quiz', 'info');

                        } else if (aiTest.status === 'completed') {
                            testTimer.textContent = formatTime(aiTest.duration || 0);
                            startQuizTimerBtn.classList.add('hidden');
                            nextQuestionBtn.classList.add('hidden');
                            prevQuestionBtn.classList.add('hidden');
                            submitQuizBtn.classList.add('hidden');
                            saveAndQuitQuizBtn.classList.add('hidden'); 
                            quizQuestionOptions.querySelectorAll('input').forEach(input => input.disabled = true); 
                            quizWrittenAnswerInput.disabled = true;

                            quizEvaluationArea.classList.remove('hidden');
                            if (aiTest.aiEvaluation) {
                                const aiResponseText = aiTest.aiEvaluation;
                                const scoreMatch = aiResponseText.match(/Score Final:\s*(\d+)\/(\d+)/); 
                                const noteMatch = aiResponseText.match(/Note de Compr√©hension \(1-5\):\s*(\d)\/5/);
                                const evaluationMatch = aiResponseText.match(/√âvaluation de l'IA:\s*([\s\S]*?)(?=Corrig√© D√©taill√©:|$)/);
                                const correctionMatch = aiResponseText.match(/Corrig√© D√©taill√©:\s*([\s\S]*)/);

                                let scoreFinal = scoreMatch ? `${scoreMatch[1]}/${scoreMatch[2]}` : 'N/A';
                                let noteComprehension = noteMatch ? parseInt(noteMatch[1]) : 'N/A';
                                let evaluationContent = evaluationMatch ? evaluationMatch[1].trim() : 'Non disponible.';
                                let correctionContent = correctionMatch ? correctionMatch[1].trim() : 'Non disponible.';

                                quizResultsSummary.innerHTML = marked.parse(`**Score Final:** ${scoreFinal} | **Note de Compr√©hension:** ${noteComprehension}/5`);
                                quizAIEvaluation.innerHTML = marked.parse(evaluationContent);
                                quizCorrectionContent.innerHTML = marked.parse(correctionContent);
                                quizAIEvaluation.classList.remove('hidden');
                                quizCorrectionContent.classList.remove('hidden');
                                reEvaluateUnderstandingBtn.classList.remove('hidden');
                            } else {
                                quizResultsSummary.textContent = "R√©sultats de l'√©valuation AI non disponibles.";
                            }
                            showAlert('Ce quiz est d√©j√† termin√©. Dur√©e : ' + formatTime(aiTest.duration || 0), 'Quiz Termin√©', 'info');
                        } else { 
                            // Status 'pending'
                            startQuizTimerBtn.textContent = '‚ñ∂Ô∏è D√©marrer le Quiz'; // Ensure it says Start
                            saveAndQuitQuizBtn.classList.remove('hidden'); // Ensure visible
                        }
                    } else { 
                        showAlert("Ce test est un ancien format texte. Veuillez utiliser la fonctionnalit√© de r√©vision pour le document li√© si vous souhaitez le revoir.", "Ancien format de test", "warning");
                        doTestModal.classList.add('hidden'); 
                    }
                    doTestModal.classList.remove('hidden');
                }
            }
        }


        // Navigation Suivant / Pr√©c√©dent
        nextQuestionBtn.addEventListener('click', () => {
            if (currentQuestionIndex < currentAITestBeingAnswered.structuredContent.questions.length - 1) {
                currentQuestionIndex++;
                renderQuestion(currentQuestionIndex);
            }
        });

        prevQuestionBtn.addEventListener('click', () => {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                renderQuestion(currentQuestionIndex);
            }
        });

        // D√©marrer ou Reprendre le minuteur du quiz
        startQuizTimerBtn.addEventListener('click', () => {
            if (currentAITestBeingAnswered) {
                startQuizTimerBtn.classList.add('hidden');
                saveAndQuitQuizBtn.classList.remove('hidden'); 
                if (currentAITestBeingAnswered.status !== 'in_progress') {
                    currentAITestBeingAnswered.status = 'in_progress';
                    currentAITestBeingAnswered.startTime = new Date().toISOString();
                }
                timerInterval = setInterval(updateTimer, 1000);
                saveDocuments();
                if (currentAITestBeingAnswered.structuredContent.questions.length > 1) {
                    nextQuestionBtn.classList.remove('hidden');
                    prevQuestionBtn.classList.remove('hidden');
                }
                if (currentQuestionIndex === currentAITestBeingAnswered.structuredContent.questions.length - 1) {
                    submitQuizBtn.classList.remove('hidden');
                    nextQuestionBtn.classList.add('hidden');
                }
                showAlert('Quiz d√©marr√©/repris ! Bonne chance.', 'Quiz En Cours', 'info');
            }
        });

        // Mettre √† jour le minuteur
        function updateTimer() {
            secondsElapsed++;
            testTimer.textContent = formatTime(secondsElapsed);
        }

        // Sauvegarder et Quitter le Quiz
        saveAndQuitQuizBtn.addEventListener('click', async () => {
            if (!currentAITestBeingAnswered) {
                showAlert("Erreur: Aucun quiz actif √† sauvegarder.", "Erreur", 'error');
                return;
            }

            const confirmed = await showConfirm('Voulez-vous sauvegarder votre progression et quitter le quiz ? Vous pourrez le reprendre plus tard.', 'Sauvegarder et Quitter');
            if (!confirmed) {
                return;
            }

            clearInterval(timerInterval);
            currentAITestBeingAnswered.duration = secondsElapsed; 
            currentAITestBeingAnswered.status = 'in_progress'; 
            currentAITestBeingAnswered.currentQuestionIndex = currentQuestionIndex; 
            saveDocuments();
            doTestModal.classList.add('hidden');
            currentAITestBeingAnswered = null; 
            currentDocumentForTest = null; 
            renderAITests(); 
            showAlert('Quiz sauvegard√© ! Vous pourrez le reprendre depuis la liste "Mes Tests AI".', 'Sauvegarde R√©ussie', 'success');
        });


        // Terminer le quiz et soumettre les r√©ponses √† l'IA pour √©valuation
        submitQuizBtn.addEventListener('click', async () => {
            // V√©rifier si la cl√© API est pr√©sente
            if (!apiKey) {
                showAlert("Cl√© API Gemini non configur√©e. Impossible d'√©valuer le test AI.", "Cl√© API manquante", "error");
                return;
            }

            if (!currentAITestBeingAnswered || !currentDocumentForTest) {
                showAlert("Erreur: Aucun quiz ou document actif pour l'√©valuation AI.", "Erreur", 'error');
                return;
            }

            const confirmed = await showConfirm('Voulez-vous terminer le quiz et soumettre vos r√©ponses pour √©valuation ?', 'Confirmer la fin du Quiz');
            if (!confirmed) {
                return;
            }

            clearInterval(timerInterval);
            currentAITestBeingAnswered.endTime = new Date().toISOString();
            currentAITestBeingAnswered.duration = secondsElapsed;
            currentAITestBeingAnswered.currentQuestionIndex = currentQuestionIndex; 

            startQuizTimerBtn.classList.add('hidden'); 
            nextQuestionBtn.classList.add('hidden'); 
            prevQuestionBtn.classList.add('hidden'); 
            submitQuizBtn.classList.add('hidden'); 
            saveAndQuitQuizBtn.classList.add('hidden'); 

            quizQuestionOptions.querySelectorAll('input').forEach(input => input.disabled = true); 
            quizWrittenAnswerInput.disabled = true;

            quizEvaluationArea.classList.remove('hidden');
            quizAIEvaluation.textContent = '';
            quizCorrectionContent.textContent = '';
            quizResultsSummary.textContent = '';
            quizGenerationLoading.classList.add('hidden'); 
            quizAIEvaluation.classList.add('hidden'); 
            quizCorrectionContent.classList.add('hidden'); 
            
            const evaluationSpinner = document.createElement('div');
            evaluationSpinner.id = 'evaluationSpinner';
            evaluationSpinner.className = 'flex justify-center items-center py-4';
            evaluationSpinner.innerHTML = `<div class="loading-spinner"></div><p class="ml-4 text-gray-600">L'IA √©value vos r√©ponses et g√©n√®re le corrig√©...</p>`;
            quizEvaluationArea.insertBefore(evaluationSpinner, quizAIEvaluation);

            try {
                const docOriginalContent = currentDocumentForTest.content;
                const quizQuestions = currentAITestBeingAnswered.structuredContent.questions;
                const userAnswers = currentAITestBeingAnswered.userAnswers;

                let questionAnswerSummary = "";
                quizQuestions.forEach((q, index) => {
                    questionAnswerSummary += `Question ${index + 1} (${q.type === 'qcm' ? 'QCM' : '√âcrit'}): ${q.text}\n`;
                    if (q.type === 'qcm') {
                        questionAnswerSummary += `Votre r√©ponse: ${q.options.find(opt => opt.id === userAnswers[index])?.text || "Non r√©pondu"}\n`;
                        questionAnswerSummary += `Bonne r√©ponse: ${q.options.find(opt => opt.id === q.correctAnswerId)?.text}\n\n`;
                    } else if (q.type === 'written') {
                        questionAnswerSummary += `Votre r√©ponse: ${userAnswers[index] || "Non r√©pondu"}\n`;
                        questionAnswerSummary += `R√©ponse attendue: ${q.correctAnswerText || "Non sp√©cifi√©e"}\n\n`;
                    }
                });

                let prompt = `En tant qu'√©valuateur expert et p√©dagogue, vous devez √©valuer les r√©ponses d'un apprenant √† un quiz interactif.
Le quiz a √©t√© g√©n√©r√© √† partir du contenu original suivant :
---
Contenu original du document :
${docOriginalContent}
---

Voici les questions du quiz et les r√©ponses de l'apprenant, ainsi que les bonnes r√©ponses :
---
${questionAnswerSummary}
---

Veuillez effectuer les t√¢ches suivantes:
1.  **Calculer le score brut de l'apprenant** sur ${quizQuestions.length} questions (par exemple, 3/${quizQuestions.length}). Pour les questions √©crites, √©valuez la pertinence de la r√©ponse par rapport √† la r√©ponse attendue et au contenu original.
2.  **Attribuer une note g√©n√©rale de 1 √† 5** √† la compr√©hension globale de l'apprenant, en consid√©rant la pertinence et l'exhaustivit√© de ses r√©ponses par rapport au contenu original et aux questions pos√©es.
    * 1 = Compr√©hension tr√®s faible, erreurs majeures.
    * 2 = Compr√©hension limit√©e, beaucoup de lacunes.
    * 3 = Compr√©hension acceptable, quelques impr√©cisions.
    * 4 = Bonne compr√©hension, d√©tails mineurs √† am√©liorer.
    * 5 = Excellente compr√©hension, pr√©cis et complet.
3.  **Fournir une √©valuation d√©taill√©e et constructive** expliquant pourquoi cette note a √©t√© attribu√©e. Mettez en √©vidence les points forts et les axes d'am√©lioration.
4.  **G√©n√©rer un corrig√© d√©taill√©** question par question, expliquant la bonne r√©ponse et pourquoi elle est correcte, en se r√©f√©rant au contenu original si pertinent. Pour les questions √©crites, comparez la r√©ponse de l'apprenant √† la r√©ponse attendue.

Votre r√©ponse doit √™tre structur√©e comme follows en utilisant des sections claires et du Markdown pour une meilleure lisibilit√©:
---
**Score Final: [Score Brute]/${quizQuestions.length}**
**Note de Compr√©hension (1-5): [Note]/5**

**√âvaluation de l'IA:**
[Votre √©valuation d√©taill√©e ici, en utilisant des listes √† puces ou num√©rot√©es si pertinent]

**Corrig√© D√©taill√©:**
[Corrig√© question par question, en utilisant des listes √† puces ou num√©rot√©es si pertinent]
---`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Erreur API lors de l\'√©valuation AI:', response.status, response.statusText, errorData);
                    quizResultsSummary.textContent = `Erreur lors de l'√©valuation AI (Code: ${response.status}). D√©tails: ${errorData.error?.message || 'Inconnu'}`;
                    showAlert(`Erreur lors de l'√©valuation du quiz: ${response.status}`, 'Erreur AI', 'error');
                } else {
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        
                        const scoreMatch = aiResponseText.match(/Score Final:\s*(\d+)\/(\d+)/); 
                        const noteMatch = aiResponseText.match(/Note de Compr√©hension \(1-5\):\s*(\d)\/5/);
                        const evaluationMatch = aiResponseText.match(/√âvaluation de l'IA:\s*([\s\S]*?)(?=Corrig√© D√©taill√©:|$)/);
                        const correctionMatch = aiResponseText.match(/Corrig√© D√©taill√©:\s*([\s\S]*)/);

                        let scoreFinal = scoreMatch ? `${scoreMatch[1]}/${scoreMatch[2]}` : 'N/A';
                        let noteComprehension = noteMatch ? parseInt(noteMatch[1]) : 'N/A';
                        let evaluationContent = evaluationMatch ? evaluationMatch[1].trim() : 'Non disponible.';
                        let correctionContent = correctionMatch ? correctionMatch[1].trim() : 'Non disponible.';

                        quizResultsSummary.innerHTML = marked.parse(`**Score Final:** ${scoreFinal} | **Note de Compr√©hension:** ${noteComprehension}/5`);
                        quizAIEvaluation.innerHTML = marked.parse(evaluationContent);
                        quizCorrectionContent.innerHTML = marked.parse(correctionContent);

                        currentAITestBeingAnswered.aiEvaluation = aiResponseText; 
                        currentAITestBeingAnswered.aiScore = noteComprehension; 
                        currentAITestBeingAnswered.status = 'completed'; 
                        saveDocuments();

                        quizAIEvaluation.classList.remove('hidden');
                        quizCorrectionContent.classList.remove('hidden');
                        reEvaluateUnderstandingBtn.classList.remove('hidden'); 
                        showAlert('Vos r√©ponses ont √©t√© √©valu√©es par l\'IA !', 'Quiz Termin√©', 'success');
                    } else {
                        console.error('Structure de r√©ponse inattendue de l\'API Gemini pour l\'√©valuation:', result);
                        quizResultsSummary.textContent = "D√©sol√©, l'IA n'a pas pu √©valuer vos r√©ponses. La r√©ponse de l'IA n'√©tait pas au format attendu. Veuillez r√©essayer.";
                        showAlert('La r√©ponse de l\'IA √©tait inattendue.', 'Erreur AI', 'error');
                    }
                }
            } catch (error) {
                console.error('Erreur lors de l\'appel de l\'API Gemini pour l\'√©valuation:', error);
                quizResultsSummary.textContent = "Une erreur est survenue lors de l'√©valuation par l'IA. Veuillez v√©rifier votre connexion internet ou r√©essayer plus tard.";
                showAlert('Erreur de connexion lors de l\'√©valuation par l\'IA.', 'Erreur R√©seau', 'error');
            } finally {
                const spinnerToRemove = document.getElementById('evaluationSpinner');
                if (spinnerToRemove) spinnerToRemove.remove();
                quizAIEvaluation.classList.remove('hidden');
                quizCorrectionContent.classList.remove('hidden');
                
                renderAITests(); 
            }
        });


        // G√©rer le passage de la modale de quiz √† la modale de r√©vision
        reEvaluateUnderstandingBtn.addEventListener('click', () => {
            doTestModal.classList.add('hidden'); 

            if (currentAITestBeingAnswered) {
                const doc = documents.find(d => d.aiTests && d.aiTests.some(test => test.id === currentAITestBeingAnswered.id));
                currentReviewingDocumentId = doc ? doc.id : null;

                if (doc) {
                    modalDocumentName.textContent = doc.name;
                    // Render Markdown content (if any) or plain text
                    const content = doc.content;
                    modalDocumentContent.innerHTML = marked.parse(content);

                    reviewModal.classList.remove('hidden');
                    scoreButtons.forEach(btn => btn.classList.remove('selected'));
                    submitReviewBtn.disabled = true;

                    if (currentAITestBeingAnswered.aiScore !== undefined && typeof currentAITestBeingAnswered.aiScore === 'number' && currentAITestBeingAnswered.aiScore >= 1 && currentAITestBeingAnswered.aiScore <= 5) {
                        const scoreBtn = document.querySelector(`.score-button[data-score="${currentAITestBeingAnswered.aiScore}"]`);
                        if (scoreBtn) {
                            scoreBtn.click(); 
                        }
                    } else {
                        selectedScore = null;
                        submitReviewBtn.disabled = true; 
                    }
                }
            }
        });

        // Annuler/Fermer la modale de test AI / Quiz
        closeQuizResultsBtn.addEventListener('click', () => {
            doTestModal.classList.add('hidden');
            clearInterval(timerInterval);
            currentAITestBeingAnswered = null; 
            currentDocumentForTest = null; 
            quizGenerationLoading.classList.add('hidden');
            quizDisplayArea.classList.add('hidden');
            quizEvaluationArea.classList.add('hidden');
            startQuizTimerBtn.classList.remove('hidden'); 
            nextQuestionBtn.classList.add('hidden');
            prevQuestionBtn.classList.add('hidden');
            submitQuizBtn.classList.add('hidden');
            saveAndQuitQuizBtn.classList.add('hidden'); 
            renderAITests(); 
        });

        // G√©rer le clic sur le bouton "Supprimer"
        async function handleDeleteButtonClick(event) {
            const docId = event.target.dataset.id;
            const docToDelete = documents.find(d => d.id === docId);

            if (docToDelete) {
                const confirmed = await showConfirm(`√ätes-vous s√ªr de vouloir supprimer le document "${docToDelete.name}" ? Cette action est irr√©versible.`, 'Confirmation de suppression');
                if (confirmed) {
                    documents = documents.filter(doc => doc.id !== docId);
                    saveDocuments(); 
                    renderDocuments();
                    renderAITests(); 
                    showAlert(`Le document "${docToDelete.name}" a √©t√© supprim√©.`, 'Suppression r√©ussie', 'success');
                }
            }
        }

        // G√©rer le clic sur le bouton "Supprimer" d'un test AI
        async function handleDeleteAITestButtonClick(event) {
            const docId = event.target.dataset.docId;
            const testId = event.target.dataset.testId;

            const doc = documents.find(d => d.id === docId);
            if (doc && doc.aiTests) {
                const testToDelete = doc.aiTests.find(test => test.id === testId);
                if (testToDelete) {
                    const confirmed = await showConfirm(`√ätes-vous s√ªr de vouloir supprimer ce test AI pour "${doc.name}" ?`, 'Confirmation de suppression du test AI');
                    if (confirmed) {
                        doc.aiTests = doc.aiTests.filter(test => test.id !== testId);
                        saveDocuments(); 
                        renderAITests();
                        showAlert('Le test AI a √©t√© supprim√©.', 'Suppression r√©ussie', 'success');
                    }
                }
            }
        }

        // G√©rer la s√©lection du score dans la modale de r√©vision
        scoreButtons.forEach(button => {
            button.addEventListener('click', () => {
                scoreButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedScore = parseInt(button.dataset.score);
                submitReviewBtn.disabled = false;
            });
        });

        submitReviewBtn.addEventListener('click', () => {
            if (currentReviewingDocumentId && selectedScore !== null) {
                const docIndex = documents.findIndex(d => d.id === currentReviewingDocumentId);
                if (docIndex !== -1) {
                    calculateNextReview(documents[docIndex], selectedScore);
                    renderDocuments();
                    reviewModal.classList.add('hidden');
                    currentReviewingDocumentId = null;
                    selectedScore = null;
                    showAlert('Document r√©vis√© avec succ√®s !', 'R√©vision Compl√®te', 'success');
                }
            }
        });


        // G√©rer le clic sur le bouton "Voir le corrig√©" (utilis√© si le test est de type texte simple)
        closeCorrectionBtn.addEventListener('click', () => {
            correctionModal.classList.add('hidden');
        });

        // Gestion des cat√©gories et sous-cat√©gories
        manageCategoriesBtn.addEventListener('click', () => {
            categoryManagementModal.classList.remove('hidden');
            renderCategoriesList();
        });

        closeCategoryManagementBtn.addEventListener('click', () => {
            categoryManagementModal.classList.add('hidden');
            populateCategorySelectors();
            populateFilterCategorySelectors();
        });

        addCategoryBtn.addEventListener('click', () => {
            const newCategoryName = newCategoryNameInput.value.trim();
            if (newCategoryName) {
                if (categories.some(cat => cat.name.toLowerCase() === newCategoryName.toLowerCase())) {
                    showAlert('Cette cat√©gorie existe d√©j√† !', 'Doublon', 'warning');
                    return;
                }
                categories.push({ id: crypto.randomUUID(), name: newCategoryName, subcategories: [] });
                saveDocuments();
                newCategoryNameInput.value = '';
                renderCategoriesList();
                showAlert('Cat√©gorie ajout√©e avec succ√®s !', 'Succ√®s', 'success');
            } else {
                showAlert('Veuillez entrer un nom pour la cat√©gorie.', 'Champ vide', 'error');
            }
        });

        function renderCategoriesList() {
            categoriesList.innerHTML = '';
            if (categories.length === 0) {
                categoriesList.innerHTML = '<li class="text-gray-600 italic">Aucune cat√©gorie pour l\'instant.</li>';
                return;
            }

            categories.forEach(cat => {
                const categoryItem = document.createElement('li');
                categoryItem.className = 'bg-gray-100 p-3 rounded-lg shadow-sm';
                categoryItem.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">${cat.name}</span>
                        <div class="flex gap-2">
                            <button data-category-id="${cat.id}" class="btn btn-secondary add-subcategory-btn">‚ûï Sous-cat√©gorie</button>
                            <button data-category-id="${cat.id}" class="btn btn-danger delete-category-btn">üóëÔ∏è Supprimer</button>
                        </div>
                    </div>
                    <ul class="ml-4 mt-2 space-y-1" id="subcategories-list-${cat.id}">
                        ${cat.subcategories.length > 0 ? 
                            cat.subcategories.map(sub => `
                                <li class="flex justify-between items-center bg-gray-200 p-2 rounded-md">
                                    <span class="text-sm text-gray-700">${sub.name}</span>
                                    <button data-category-id="${cat.id}" data-subcategory-id="${sub.id}" class="btn btn-danger text-xs px-2 py-1 delete-subcategory-btn">üóëÔ∏è</button>
                                </li>
                            `).join('')
                            : '<li class="text-gray-500 italic text-sm">Aucune sous-cat√©gorie.</li>'
                        }
                    </ul>
                `;
                categoriesList.appendChild(categoryItem);
            });
            attachCategoryListEventListeners();
        }

        function attachCategoryListEventListeners() {
            document.querySelectorAll('.add-subcategory-btn').forEach(button => {
                button.removeEventListener('click', handleAddSubcategoryClick); 
                button.addEventListener('click', handleAddSubcategoryClick);
            });
            document.querySelectorAll('.delete-category-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteCategoryClick); 
                button.addEventListener('click', handleDeleteCategoryClick);
            });
            document.querySelectorAll('.delete-subcategory-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteSubcategoryClick); 
                button.addEventListener('click', handleDeleteSubcategoryClick);
            });
        }

        async function handleAddSubcategoryClick(event) {
            const categoryId = event.target.dataset.categoryId;
            const category = categories.find(cat => cat.id === categoryId);
            if (category) {
                // Remplac√© prompt() par une alerte personnalis√©e avec input si n√©cessaire, ou simplification
                const subcategoryName = prompt(`Ajouter une sous-cat√©gorie pour "${category.name}" :`);
                if (subcategoryName && subcategoryName.trim()) {
                    if (category.subcategories.some(sub => sub.name.toLowerCase() === subcategoryName.trim().toLowerCase())) {
                        showAlert('Cette sous-cat√©gorie existe d√©j√† !', 'Doublon', 'warning');
                        return;
                    }
                    category.subcategories.push({ id: crypto.randomUUID(), name: subcategoryName.trim() });
                    saveDocuments();
                    renderCategoriesList();
                    showAlert('Sous-cat√©gorie ajout√©e avec succ√®s !', 'Succ√®s', 'success');
                } else if (subcategoryName !== null) { 
                    showAlert('Veuillez entrer un nom pour la sous-cat√©gorie.', 'Champ vide', 'error');
                }
            }
        }

        async function handleDeleteCategoryClick(event) {
            const categoryId = event.target.dataset.categoryId;
            const categoryToDelete = categories.find(cat => cat.id === categoryId);
            if (categoryToDelete) {
                const confirmed = await showConfirm(`√ätes-vous s√ªr de vouloir supprimer la cat√©gorie "${categoryToDelete.name}" et toutes ses sous-cat√©gories ? Les documents associ√©s seront "Non class√©s".`, 'Confirmation de suppression');
                if (confirmed) {
                    categories = categories.filter(cat => cat.id !== categoryId);
                    documents.forEach(doc => {
                        if (doc.category === categoryToDelete.name) {
                            doc.category = 'Non class√©';
                            doc.subcategory = 'Non class√©'; 
                        }
                    });
                    saveDocuments();
                    renderCategoriesList();
                    renderDocuments(); 
                    showAlert('Cat√©gorie supprim√©e.', 'Succ√®s', 'success');
                }
            }
        }

        async function handleDeleteSubcategoryClick(event) {
            const categoryId = event.target.dataset.categoryId;
            const subcategoryId = event.target.dataset.subcategoryId;
            const category = categories.find(cat => cat.id === categoryId);

            if (category) {
                const subcategoryToDelete = category.subcategories.find(sub => sub.id === subcategoryId);
                if (subcategoryToDelete) {
                    const confirmed = await showConfirm(`√ätes-vous s√ªr de vouloir supprimer la sous-cat√©gorie "${subcategoryToDelete.name}" ? Les documents associ√©s seront "Non class√©s".`, 'Supprimer la sous-cat√©gorie');
                    if (confirmed) {
                        category.subcategories = category.subcategories.filter(sub => sub.id !== subcategoryId);
                        documents.forEach(doc => {
                            if (doc.subcategory === subcategoryToDelete.name && doc.category === category.name) {
                                doc.subcategory = 'Non class√©';
                            }
                        });
                        saveDocuments();
                        renderCategoriesList();
                        renderDocuments(); 
                        showAlert('Sous-cat√©gorie supprim√©e.', 'Succ√®s', 'success');
                    }
                }
            }
        }

        // Fonction pour afficher les messages dans le chat AI
        function displayChatMessage(role, text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `p-2 rounded-lg max-w-[80%] my-1 text-sm `; 
            
            if (role === 'user') {
                messageDiv.classList.add('chat-message-user'); 
            } else {
                // Keep 'chat-message-ai' class for styling, but API role is 'model'
                messageDiv.classList.add('chat-message-ai'); 
            }
            messageDiv.textContent = text; // Use textContent for security and simple display
            aiChatDisplay.appendChild(messageDiv);
            aiChatDisplay.scrollTop = aiChatDisplay.scrollHeight; 
        }

        // √âv√©nement d'envoi de message au chat AI
        sendAIChatBtn.addEventListener('click', async () => {
            // V√©rifier si la cl√© API est pr√©sente
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre cl√© API Gemini. Le chat AI ne fonctionnera pas sans elle.", "Cl√© API manquante", "warning");
                return;
            }

            const userMessage = aiChatInput.value.trim();
            if (!userMessage) {
                showAlert("Veuillez taper votre question.", "Question vide", 'warning');
                return;
            }

            const doc = documents.find(d => d.id === currentReviewingDocumentId);
            if (!doc) {
                showAlert("Erreur: Document non trouv√© pour le chat AI.", "Erreur Chat", 'error');
                return;
            }

            displayChatMessage('user', userMessage);
            doc.aiChatHistory.push({ role: 'user', text: userMessage });
            saveDocuments();
            aiChatInput.value = ''; 
            aiChatLoading.classList.remove('hidden'); 
            sendAIChatBtn.disabled = true; 

            try {
                const documentContent = doc.content;
                // Construct the prompt using the entire chat history for context
                let currentChatHistory = doc.aiChatHistory.map(msg => ({
                    role: msg.role === 'ai' ? 'model' : msg.role, // FIX: Map 'ai' role to 'model' for API
                    parts: [{ text: msg.text }]
                }));

                // Ensure the initial system prompt is sent with the first user message only
                // This structure is fine as is, since the 'initialPrompt' becomes part of the
                // first user message's text, and subsequent turns just alternate user/model roles.
                // The main fix is ensuring all 'ai' roles from `doc.aiChatHistory` are converted to 'model'
                // when sending to the Gemini API.

                const payload = { contents: currentChatHistory }; 

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Erreur API lors du chat AI:', response.status, response.statusText, errorData);
                    displayChatMessage('ai', `D√©sol√©, une erreur est survenue lors de la communication avec l'IA. (Code: ${response.status}). Veuillez r√©essayer. D√©tails: ${errorData.error?.message || 'Inconnu'}`);
                } else {
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        displayChatMessage('ai', aiResponseText);
                        doc.aiChatHistory.push({ role: 'model', text: aiResponseText }); // FIX: Push with 'model' role
                        saveDocuments();
                    } else {
                        console.error('Structure de r√©ponse inattendue de l\'API Gemini pour le chat:', result);
                        displayChatMessage('ai', "D√©sol√©, l'IA n'a pas pu r√©pondre. La structure de la r√©ponse √©tait inattendue.");
                    }
                }
            } catch (error) {
                console.error('Erreur lors de l\'appel de l\'API Gemini pour le chat:', error);
                displayChatMessage('ai', "Une erreur est survenue lors du chat avec l'IA. V√©rifiez votre connexion internet.");
            } finally {
                aiChatLoading.classList.add('hidden'); 
                sendAIChatBtn.disabled = false; 
            }
        });

        // Add event listener for Enter key in chat input
        aiChatInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); 
                sendAIChatBtn.click(); 
            }
        });

        // Fonction d'exportation des donn√©es
        exportDataBtn.addEventListener('click', () => {
            try {
                const dataToExport = {
                    documents: documents,
                    categories: categories
                };
                const dataStr = JSON.stringify(dataToExport, null, 2); 
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rvsion_data_export_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showAlert('Donn√©es export√©es avec succ√®s !', 'Exportation R√©ussie', 'success');
            } catch (e) {
                console.error('Erreur lors de l\'exportation des donn√©es:', e);
                showAlert('Erreur lors de l\'exportation des donn√©es.', 'Erreur d\'Exportation', 'error');
            }
        });

        // Fonction d'importation des donn√©es
        importDataBtn.addEventListener('click', () => {
            importFileInput.click(); 
        });

        importFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    const confirmed = await showConfirm(
                        'L\'importation des donn√©es va remplacer toutes vos donn√©es actuelles. Voulez-vous continuer ?',
                        'Confirmer l\'Importation'
                    );

                    if (confirmed) {
                        if (importedData.documents && Array.isArray(importedData.documents) &&
                            importedData.categories && Array.isArray(importedData.categories)) {
                            
                            const isValidDocuments = importedData.documents.every(doc => 
                                doc.id && doc.name && doc.content && doc.lastReviewed && doc.nextReview
                            );
                            const isValidCategories = importedData.categories.every(cat => 
                                cat.id && cat.name && Array.isArray(cat.subcategories)
                            );

                            if (isValidDocuments && isValidCategories) {
                                documents = importedData.documents.map(doc => ({
                                    ...doc,
                                    lastReviewed: new Date(doc.lastReviewed),
                                    nextReview: new Date(doc.nextReview),
                                    aiTests: doc.aiTests ? doc.aiTests.map(test => ({
                                        ...test,
                                        generatedAt: new Date(test.generatedAt),
                                        startTime: test.startTime ? new Date(test.startTime) : null,
                                        endTime: test.endTime ? new Date(test.endTime) : null,
                                        config: test.config || { difficulty: 'Moyen', questionType: 'qcm', numQuestions: 5 }, 
                                        currentQuestionIndex: test.currentQuestionIndex !== undefined ? test.currentQuestionIndex : 0 
                                    })) : [],
                                    aiChatHistory: doc.aiChatHistory || [],
                                    flashcards: doc.flashcards || []
                                }));
                                categories = importedData.categories;
                                saveDocuments();
                                renderDocuments();
                                renderAITests();
                                showAlert('Donn√©es import√©es avec succ√®s !', 'Importation R√©ussie', 'success');
                            } else {
                                showAlert('Le fichier JSON n\'a pas le format attendu pour les documents ou les cat√©gories. Importation annul√©e.', 'Erreur de Format', 'error');
                            }
                        } else {
                            showAlert('Le fichier JSON ne contient pas les cl√©s "documents" et "categories" ou elles sont mal formatt√©es. Importation annul√©e.', 'Erreur de Format', 'error');
                        }
                    } else {
                        showAlert('Importation annul√©e par l\'utilisateur.', 'Annul√©', 'info');
                    }

                } catch (e) {
                    console.error('Erreur lors de l\'importation ou du parsing du fichier JSON:', e);
                    showAlert('Erreur lors de l\'importation du fichier. Assurez-vous que c\'est un fichier JSON valide.', 'Erreur d\'Importation', 'error');
                }
            };
            reader.readAsText(file);
        });


        // --- Global Event Listener Initialization ---
        function initGlobalEventListeners() {
            closeAlertBtn.addEventListener('click', () => {
                customAlertModal.classList.add('hidden');
            });
            cancelReviewBtn.addEventListener('click', () => {
                reviewModal.classList.add('hidden');
                currentReviewingDocumentId = null;
                selectedScore = null;
            });
            cancelTestConfigBtn.addEventListener('click', () => {
                testConfigModal.classList.add('hidden');
                currentDocumentForTest = null;
            });
            // La logique de ces boutons est d√©finie plus haut et ne doit pas √™tre r√©-assign√©e ici
            // prepareInteractiveTestBtn.addEventListener('click', async () => { /* Logic defined above */ });
            // nextQuestionBtn.addEventListener('click', () => { /* Logic defined above */ });
            // prevQuestionBtn.addEventListener('click', () => { /* Logic defined above */ });
            // startQuizTimerBtn.addEventListener('click', () => { /* Logic defined above */ });
            // submitQuizBtn.addEventListener('click', async () => { /* Logic defined above */ });
            // reEvaluateUnderstandingBtn.addEventListener('click', () => { /* Logic defined above */ });
            // closeQuizResultsBtn.addEventListener('click', () => { /* Logic defined above */ });
            // saveAndQuitQuizBtn.addEventListener('click', async () => { /* Logic defined above */ }); 
            
            searchDocumentInput.addEventListener('input', renderDocuments);
            filterStatusSelect.addEventListener('change', renderDocuments);
            documentCategorySelect.addEventListener('change', () => {
                const selectedCategoryId = documentCategorySelect.value;
                documentSubcategorySelect.innerHTML = '<option value="">S√©lectionner une sous-cat√©gorie</option>';
                documentSubcategorySelect.disabled = true;

                if (selectedCategoryId) {
                    const selectedCategory = categories.find(cat => cat.id === selectedCategoryId);
                    if (selectedCategory && selectedCategory.subcategories.length > 0) {
                        selectedCategory.subcategories.forEach(sub => {
                            const option = document.createElement('option');
                            option.value = sub.id;
                            option.textContent = sub.name;
                            documentSubcategorySelect.appendChild(option);
                        });
                        documentSubcategorySelect.disabled = false;
                    }
                }
            });
            filterCategorySelect.addEventListener('change', () => {
                const selectedCategoryId = filterCategorySelect.value;
                filterSubcategorySelect.innerHTML = '<option value="all">Toutes sous-cat√©gories</option>';
                filterSubcategorySelect.disabled = true;

                if (selectedCategoryId && selectedCategoryId !== 'all') {
                    const selectedCategory = categories.find(cat => cat.id === selectedCategoryId);
                    if (selectedCategory && selectedCategory.subcategories.length > 0) {
                        selectedCategory.subcategories.forEach(sub => {
                            const option = document.createElement('option');
                            option.value = sub.id;
                            option.textContent = sub.name;
                            filterSubcategorySelect.appendChild(option);
                        });
                        filterSubcategorySelect.disabled = false;
                    }
                }
                renderDocuments();
            });
            filterSubcategorySelect.addEventListener('change', renderDocuments);
            // exportDataBtn.addEventListener('click', () => { /* Logic defined above */ });
            // importDataBtn.addEventListener('click', () => { /* Logic defined above */ });
            // importFileInput.addEventListener('change', (event) => { /* Logic defined above */ });
            // closeCorrectionBtn.addEventListener('click', () => { /* Logic defined above */ });
            // manageCategoriesBtn.addEventListener('click', () => { /* Logic defined above */ });
            // closeCategoryManagementBtn.addEventListener('click', () => { /* Logic defined above */ });
            // addCategoryBtn.addEventListener('click', () => { /* Logic defined above */ });
            // scoreButtons.forEach(button => { /* Logic defined above */ });

            // Flashcard specific event listeners
            flipFlashcardBtn.addEventListener('click', () => {
                flashcardCard.classList.toggle('flipped'); // Toggle the flipped class
                isFlashcardFlipped = !isFlashcardFlipped;
            });
            prevFlashcardBtn.addEventListener('click', () => {
                if (currentFlashcardIndex > 0) {
                    currentFlashcardIndex--;
                    displayFlashcard();
                }
            });
            nextFlashcardBtn.addEventListener('click', () => {
                if (currentFlashcardIndex < currentFlashcards.length - 1) {
                    currentFlashcardIndex++;
                    displayFlashcard();
                }
            });
            closeFlashcardModalBtn.addEventListener('click', () => {
                flashcardModal.classList.add('hidden');
                currentFlashcards = [];
                currentFlashcardIndex = 0;
                isFlashcardFlipped = false;
                numFlashcardsToGenerateInput.value = ''; // Reset input
                generateFlashcardsWithAIButton.classList.add('hidden'); // Hide until doc selected again
            });

            // NEW Flashcard Management Modal Buttons
            openManageFlashcardsModalButton.addEventListener('click', () => {
                if (!currentManagingDocumentId) {
                    showAlert("Veuillez s√©lectionner un document pour g√©rer les flashcards.", "Document manquant", "warning");
                    return;
                }
                flashcardModal.classList.add('hidden'); // Hide main flashcard modal
                openManageFlashcardsModal(currentManagingDocumentId);
            });
            closeManageFlashcardsModalBtn.addEventListener('click', () => {
                manageFlashcardsModal.classList.add('hidden');
                // Reopen the main flashcard modal, preserving state if desired
                if (currentManagingDocumentId) {
                    handleFlashcardsButtonClick({ target: { dataset: { id: currentManagingDocumentId } } });
                }
            });
            generateFlashcardsWithAIButton.addEventListener('click', () => {
                const num = parseInt(numFlashcardsToGenerateInput.value);
                generateFlashcardsAI(currentManagingDocumentId, num);
            });
            addFlashcardManuallyBtn.addEventListener('click', () => {
                const question = newFlashcardQuestionInput.value.trim();
                const answer = newFlashcardAnswerInput.value.trim();

                if (question && answer) {
                    const doc = documents.find(d => d.id === currentManagingDocumentId);
                    if (doc) {
                        if (!doc.flashcards) {
                            doc.flashcards = [];
                        }
                        doc.flashcards.push({ id: crypto.randomUUID(), question, answer });
                        saveDocuments();
                        renderFlashcardsManagementList();
                        newFlashcardQuestionInput.value = '';
                        newFlashcardAnswerInput.value = '';
                        showAlert('Flashcard ajout√©e manuellement !', 'Succ√®s', 'success');
                        // If currently viewing flashcards, update display
                        if (flashcardModal.classList.contains('hidden') === false) {
                            currentFlashcards = doc.flashcards; // Update the current flashcards array
                            currentFlashcardIndex = currentFlashcards.length - 1; // Go to new card
                            displayFlashcard();
                        }
                    }
                } else {
                    showAlert('Veuillez entrer une question et une r√©ponse pour la flashcard.', 'Champs vides', 'error');
                }
            });


            // --- NEW: API Key Save Listener ---
            saveApiKeyBtn.addEventListener('click', () => {
                const newKey = apiKeyInput.value.trim();
                if (newKey) {
                    localStorage.setItem('geminiApiKey', newKey);
                    apiKey = newKey; // Update the global API key
                    showAlert('Cl√© API Gemini sauvegard√©e avec succ√®s !', 'Succ√®s', 'success');
                } else {
                    localStorage.removeItem('geminiApiKey'); // Clear the key if input is empty
                    apiKey = ""; // Clear global API key
                    showAlert('Cl√© API Gemini effac√©e du stockage local.', 'Information', 'info');
                }
            });
            // --- END NEW: API Key Save Listener ---
        }
        // --- END Global Event Listener Initialization ---

        // Handler for Flashcards button click
        async function handleFlashcardsButtonClick(event) {
            // V√©rifier si la cl√© API est pr√©sente
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre cl√© API Gemini. La g√©n√©ration de flashcards ne fonctionnera pas sans elle.", "Cl√© API manquante", "warning");
                return;
            }

            const docId = event.target.dataset.id;
            const doc = documents.find(d => d.id === docId);
            if (!doc) return;

            flashcardModal.classList.remove('hidden');
            flashcardLoading.classList.remove('hidden');
            flipFlashcardBtn.disabled = true;
            prevFlashcardBtn.disabled = true;
            nextFlashcardBtn.disabled = true;
            flashcardQuestionDisplay.innerHTML = ''; // Use innerHTML for Markdown
            flashcardAnswerDisplay.innerHTML = ''; // Use innerHTML for Markdown
            flashcardCard.classList.remove('flipped'); // Ensure not flipped initially
            isFlashcardFlipped = false;
            currentManagingDocumentId = docId; // Set the document being managed for flashcards

            if (doc.flashcards && doc.flashcards.length > 0) {
                currentFlashcards = doc.flashcards;
                currentFlashcardIndex = 0;
                flashcardLoading.classList.add('hidden');
                displayFlashcard();
            } else {
                // If no flashcards, suggest generation
                flashcardLoading.classList.add('hidden');
                showAlert("Aucune flashcard existante. G√©n√©rez-en via l'IA ou ajoutez-en manuellement.", "Flashcards", "info");
                numFlashcardsToGenerateInput.value = '10'; // Default value
                displayFlashcard(); // Display "no flashcards" message
            }
        }

        async function generateFlashcardsAI(docId, numFlashcards) {
            if (!apiKey) {
                showAlert("Veuillez d'abord sauvegarder votre cl√© API Gemini. La g√©n√©ration de flashcards ne fonctionnera pas sans elle.", "Cl√© API manquante", "warning");
                return;
            }
            const doc = documents.find(d => d.id === docId);
            if (!doc) return;

            flashcardLoading.classList.remove('hidden');
            flipFlashcardBtn.disabled = true;
            prevFlashcardBtn.disabled = true;
            nextFlashcardBtn.disabled = true;

            try {
                let prompt = `G√©n√®re ${numFlashcards && !isNaN(numFlashcards) ? numFlashcards : '10'} flashcards (question et r√©ponse) en format JSON √† partir du texte suivant.
                Le JSON doit avoir une propri√©t√© "flashcards" qui est un tableau d'objets. Chaque objet flashcard doit avoir les propri√©t√©s "question" (string) et "answer" (string).
                Utilise le formatage Markdown (texte en gras avec **, listes √† puces avec -) pour le contenu des questions et r√©ponses si cela am√©liore la clart√©.
                Texte du document:
                ---
                ${doc.content}
                ---
                Fournis uniquement le JSON.`;

                // If numFlashcards is not provided, modify prompt for AI to decide
                if (!numFlashcards || isNaN(numFlashcards)) {
                    prompt = `G√©n√®re un nombre suffisant et pertinent de flashcards (question et r√©ponse) en format JSON √† partir du texte suivant.
                    Le JSON doit avoir une propri√©t√© "flashcards" qui est un tableau d'objets. Chaque objet flashcard doit avoir les propri√©t√©s "question" (string) et "answer" (string).
                    Utilise le formatage Markdown (texte en gras avec **, listes √† puces avec -) pour le contenu des questions et r√©ponses si cela am√©liore la clart√©.
                    Texte du document:
                    ---
                    ${doc.content}
                    ---
                    Fournis uniquement le JSON.`;
                }


                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "flashcards": {
                                    "type": "ARRAY",
                                    "items": {
                                        "type": "OBJECT",
                                        "properties": {
                                            "question": { "type": "STRING" },
                                            "answer": { "type": "STRING" }
                                        },
                                        "required": ["question", "answer"]
                                    }
                                }
                            },
                            "required": ["flashcards"]
                        }
                    }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`√âchec de l'IA: ${errorData.error?.message || response.statusText}`);
                }
                const result = await response.json();
                const flashcardData = JSON.parse(result.candidates[0].content.parts[0].text);

                if (flashcardData.flashcards && Array.isArray(flashcardData.flashcards) && flashcardData.flashcards.length > 0) {
                    doc.flashcards = flashcardData.flashcards.map(fc => ({
                        id: crypto.randomUUID(), // Add unique ID for manual editing/deletion
                        question: fc.question,
                        answer: fc.answer
                    }));
                    saveDocuments();
                    currentFlashcards = doc.flashcards;
                    currentFlashcardIndex = 0;
                    displayFlashcard();
                    showAlert('Flashcards g√©n√©r√©es avec succ√®s !', 'Succ√®s AI', 'success');
                } else {
                    showAlert('L\'IA n\'a pas pu g√©n√©rer les flashcards.', 'Erreur AI', 'error');
                    flashcardModal.classList.add('hidden');
                }
            } catch (error) {
                console.error('Erreur lors de la g√©n√©ration des flashcards:', error);
                showAlert('Erreur lors de la g√©n√©ration des flashcards: ' + error.message, 'Erreur AI', 'error');
                flashcardModal.classList.add('hidden');
            } finally {
                flashcardLoading.classList.add('hidden');
                flipFlashcardBtn.disabled = currentFlashcards.length === 0;
                prevFlashcardBtn.disabled = currentFlashcards.length === 0 || currentFlashcardIndex === 0;
                nextFlashcardBtn.disabled = currentFlashcards.length === 0 || currentFlashcardIndex === currentFlashcards.length - 1;
            }
        }

        // Display current flashcard
        function displayFlashcard() {
            if (currentFlashcards.length === 0) {
                flashcardQuestionDisplay.innerHTML = marked.parse("Aucune flashcard disponible. G√©n√©rez-en via l'IA ou ajoutez-en manuellement.");
                flashcardAnswerDisplay.innerHTML = "";
                flashcardCard.classList.remove('flipped');
                isFlashcardFlipped = false;
                flipFlashcardBtn.disabled = true;
                prevFlashcardBtn.disabled = true;
                nextFlashcardBtn.disabled = true;
                currentFlashcardIndexDisplay.textContent = 0;
                totalFlashcardsDisplay.textContent = 0;
                return;
            }

            const flashcard = currentFlashcards[currentFlashcardIndex];
            flashcardQuestionDisplay.innerHTML = marked.parse(flashcard.question);
            flashcardAnswerDisplay.innerHTML = marked.parse(flashcard.answer);
            
            // Reset flip state and hide back of card
            flashcardCard.classList.remove('flipped'); 
            isFlashcardFlipped = false;

            currentFlashcardIndexDisplay.textContent = currentFlashcardIndex + 1;
            totalFlashcardsDisplay.textContent = currentFlashcards.length;

            flipFlashcardBtn.disabled = false;
            prevFlashcardBtn.disabled = (currentFlashcardIndex === 0);
            nextFlashcardBtn.disabled = (currentFlashcardIndex === currentFlashcards.length - 1);
        }

        // Flashcard Management functions
        function openManageFlashcardsModal(docId) {
            currentManagingDocumentId = docId;
            const doc = documents.find(d => d.id === docId);
            if (!doc) return;

            manageFlashcardsDocumentName.textContent = doc.name;
            renderFlashcardsManagementList();
            manageFlashcardsModal.classList.remove('hidden');
            newFlashcardQuestionInput.value = '';
            newFlashcardAnswerInput.value = '';
        }

        function renderFlashcardsManagementList() {
            flashcardsManagementList.innerHTML = '';
            const doc = documents.find(d => d.id === currentManagingDocumentId);
            if (!doc || !doc.flashcards || doc.flashcards.length === 0) {
                flashcardsManagementList.innerHTML = '<li class="text-gray-600 italic">Aucune flashcard pour l\'instant.</li>';
                return;
            }

            doc.flashcards.forEach(fc => {
                const li = document.createElement('li');
                li.className = 'bg-gray-100 p-3 rounded-lg shadow-sm';
                li.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800 flex-grow mr-2">Q: ${marked.parse(fc.question).replace(/<p>|<\/p>/g, '')}</span>
                        <div class="flex gap-2">
                            <button data-flashcard-id="${fc.id}" class="btn btn-info text-xs px-2 py-1 edit-flashcard-btn">‚úèÔ∏è</button>
                            <button data-flashcard-id="${fc.id}" class="btn btn-danger text-xs px-2 py-1 delete-flashcard-btn">üóëÔ∏è</button>
                        </div>
                    </div>
                    <div class="flex justify-between items-center text-sm text-gray-600">
                        <span class="flex-grow mr-2">R: ${marked.parse(fc.answer).replace(/<p>|<\/p>/g, '')}</span>
                    </div>
                `;
                flashcardsManagementList.appendChild(li);
            });

            attachFlashcardManagementEventListeners();
        }

        function attachFlashcardManagementEventListeners() {
            document.querySelectorAll('.edit-flashcard-btn').forEach(button => {
                button.removeEventListener('click', handleEditFlashcardClick);
                button.addEventListener('click', handleEditFlashcardClick);
            });
            document.querySelectorAll('.delete-flashcard-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteFlashcardClick);
                button.addEventListener('click', handleDeleteFlashcardClick);
            });
        }

        async function handleEditFlashcardClick(event) {
            const flashcardId = event.target.dataset.flashcardId;
            const doc = documents.find(d => d.id === currentManagingDocumentId);
            if (!doc) return;
            const flashcardToEdit = doc.flashcards.find(fc => fc.id === flashcardId);
            if (flashcardToEdit) {
                const newQuestion = prompt('Modifier la question:', flashcardToEdit.question);
                if (newQuestion === null) return; // User cancelled
                const newAnswer = prompt('Modifier la r√©ponse:', flashcardToEdit.answer);
                if (newAnswer === null) return; // User cancelled

                if (newQuestion.trim() && newAnswer.trim()) {
                    flashcardToEdit.question = newQuestion.trim();
                    flashcardToEdit.answer = newAnswer.trim();
                    saveDocuments();
                    renderFlashcardsManagementList();
                    showAlert('Flashcard modifi√©e avec succ√®s !', 'Succ√®s', 'success');
                    // If currently viewing flashcards, update display
                    if (flashcardModal.classList.contains('hidden') === false) {
                        displayFlashcard();
                    }
                } else {
                    showAlert('La question et la r√©ponse ne peuvent pas √™tre vides.', 'Champs vides', 'error');
                }
            }
        }

        async function handleDeleteFlashcardClick(event) {
            const flashcardId = event.target.dataset.flashcardId;
            const doc = documents.find(d => d.id === currentManagingDocumentId);
            if (!doc) return;
            const flashcardToDelete = doc.flashcards.find(fc => fc.id === flashcardId);

            if (flashcardToDelete) {
                const confirmed = await showConfirm(`√ätes-vous s√ªr de vouloir supprimer cette flashcard ?`, 'Confirmer la suppression');
                if (confirmed) {
                    doc.flashcards = doc.flashcards.filter(fc => fc.id !== flashcardId);
                    saveDocuments();
                    renderFlashcardsManagementList();
                    showAlert('Flashcard supprim√©e.', 'Succ√®s', 'success');
                    // If currently viewing flashcards, refresh display and reset index if necessary
                    if (flashcardModal.classList.contains('hidden') === false) {
                        if (currentFlashcardIndex >= doc.flashcards.length && doc.flashcards.length > 0) {
                            currentFlashcardIndex = doc.flashcards.length - 1;
                        }
                        displayFlashcard();
                    }
                }
            }
        }

        function handleEditDocumentButtonClick(event) {
            const docId = event.target.dataset.id;
            const doc = documents.find(d => d.id === docId);
            if (doc) {
                // Populate the "Add New Document" section
                documentNameInput.value = doc.name;
                documentContentInput.value = doc.content;
                aiDocumentActionSelect.value = 'none'; // Reset AI action for editing

                // Populate category and subcategory
                const categoryObj = categories.find(cat => cat.name === doc.category);
                if (categoryObj) {
                    documentCategorySelect.value = categoryObj.id;
                    // Trigger change to populate subcategories
                    const event = new Event('change');
                    documentCategorySelect.dispatchEvent(event);

                    const subcategoryObj = categoryObj.subcategories.find(sub => sub.name === doc.subcategory);
                    if (subcategoryObj) {
                        documentSubcategorySelect.value = subcategoryObj.id;
                    } else {
                        documentSubcategorySelect.value = ''; // Reset subcategory if not found
                    }
                } else {
                    documentCategorySelect.value = ''; // Reset category if not found
                    documentSubcategorySelect.innerHTML = '<option value="">S√©lectionner une sous-cat√©gorie</option>';
                    documentSubcategorySelect.disabled = true;
                }

                // Set editing state
                editingDocumentId = docId;
                addDocumentBtn.textContent = 'üíæ Enregistrer les modifications';
                showAlert(`Vous modifiez le document "${doc.name}".`, 'Modification', 'info');

                // Scroll to the add/edit section
                documentNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }


        // NEW: Load marked.js for Markdown parsing
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
        script.onload = () => {
            marked.setOptions({
                gfm: true, 
                breaks: true, 
                sanitize: true 
            });
            // Initialiser l'application apr√®s le chargement de marked.js
            loadApiKeyFromLocalStorage(); // Charger la cl√© API en premier
            window.onload = loadDocuments; 
        };
        document.head.appendChild(script);

        // Fallback if marked.js fails to load
        if (!window.marked) {
            console.warn("marked.js failed to load, Markdown rendering will not be available.");
            // Initialiser l'application m√™me si marked.js ne charge pas
            loadApiKeyFromLocalStorage(); // Charger la cl√© API en premier
            window.onload = loadDocuments; 
        }

    </script>
</body>
</html>
